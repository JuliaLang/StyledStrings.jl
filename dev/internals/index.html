<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · Styled Strings</title><meta name="title" content="Internals · Styled Strings"/><meta property="og:title" content="Internals · Styled Strings"/><meta property="twitter:title" content="Internals · Styled Strings"/><meta name="description" content="Documentation for Styled Strings."/><meta property="og:description" content="Documentation for Styled Strings."/><meta property="twitter:description" content="Documentation for Styled Strings."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Styled Strings</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">StyledStrings</a></li><li><a class="tocitem" href="../examples/">Example Usage</a></li><li class="is-active"><a class="tocitem" href>Internals</a><ul class="internal"><li><a class="tocitem" href="#Styled-Markup-parsing"><span>Styled Markup parsing</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internals</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internals</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/StyledStrings.jl/blob/main/docs/src/internals.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h1><p>Everything documented in this page is internal and subject to breaking changes,
even in minor version updates of Julia or StyledStrings.jl. If you are curious
about the internals, read on, but if you want to depend on them, please consider
opening a pull request or issue to discuss making them part of the public API.</p><article><details class="docstring" open="true"><summary id="StyledStrings.ANSI_4BIT_COLORS"><a class="docstring-binding" href="#StyledStrings.ANSI_4BIT_COLORS"><code>StyledStrings.ANSI_4BIT_COLORS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A mapping between ANSI named colours and indices in the standard 256-color
table. The standard colors are 0-7, and high intensity colors 8-15.</p><p>The high intensity colors are prefixed by &quot;bright<em>&quot;. The &quot;bright</em>black&quot; color is
given two aliases: &quot;grey&quot; and &quot;gray&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/io.jl#L5-L11">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.FACES"><a class="docstring-binding" href="#StyledStrings.FACES"><code>StyledStrings.FACES</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>Globally named <a href="../#StyledStrings.Face"><code>Face</code></a>s.</p><p><code>default</code> gives the initial values of the faces, and <code>current</code> holds the active
(potentially modified) set of faces. This two-set system allows for any
modifications to the active faces to be undone.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L3-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.MAX_COLOR_FORWARDS"><a class="docstring-binding" href="#StyledStrings.MAX_COLOR_FORWARDS"><code>StyledStrings.MAX_COLOR_FORWARDS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">MAX_COLOR_FORWARDS</code></pre><p>The maximum number of times to follow color references when resolving a color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L518-L522">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.UNRESOLVED_COLOR_FALLBACK"><a class="docstring-binding" href="#StyledStrings.UNRESOLVED_COLOR_FALLBACK"><code>StyledStrings.UNRESOLVED_COLOR_FALLBACK</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">UNRESOLVED_COLOR_FALLBACK</code></pre><p>The fallback <code>RGBTuple</code> used when asking for a color that is not defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L511-L515">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.Legacy.ANSI_256_COLORS"><a class="docstring-binding" href="#StyledStrings.Legacy.ANSI_256_COLORS"><code>StyledStrings.Legacy.ANSI_256_COLORS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A mapping from 256-color codes indicies to 8-bit colours.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/legacy.jl#L20-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.Legacy.NAMED_COLORS"><a class="docstring-binding" href="#StyledStrings.Legacy.NAMED_COLORS"><code>StyledStrings.Legacy.NAMED_COLORS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A list of all named colors recognised, including both the old <code>light_*</code> and new
<code>bright_*</code> named colors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/legacy.jl#L65-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.Legacy.RENAMED_COLORS"><a class="docstring-binding" href="#StyledStrings.Legacy.RENAMED_COLORS"><code>StyledStrings.Legacy.RENAMED_COLORS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><p>A mapping from old named colours to the new names, specifically from <code>light_*</code>
to <code>bright_*</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/legacy.jl#L76-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.Legacy.legacy_color"><a class="docstring-binding" href="#StyledStrings.Legacy.legacy_color"><code>StyledStrings.Legacy.legacy_color</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">legacy_color(color::Union{String, Symbol, Int})</code></pre><p>Attempt to obtain a <code>SimpleColor</code> for a &quot;legacy&quot; color value <code>color</code>.</p><p>When this is not possible, <code>nothing</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/legacy.jl#L11-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.Legacy.load_env_colors!"><a class="docstring-binding" href="#StyledStrings.Legacy.load_env_colors!"><code>StyledStrings.Legacy.load_env_colors!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_env_colors!()</code></pre><p>Try to emulate the effect of the various <code>*_color()</code> functions of <code>Base</code>, by
loading any specified colours as foregrounds of the relevant faces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/legacy.jl#L106-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.ansi_4bit"><a class="docstring-binding" href="#StyledStrings.ansi_4bit"><code>StyledStrings.ansi_4bit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ansi_4bit(color::Integer, background::Bool=false)</code></pre><p>Provide the color code (30-37, 40-47, 90-97, 100-107) for <code>color</code> (0–15).</p><p>When <code>background</code> is set the background variant will be provided, otherwise
the provided code is for setting the foreground color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/io.jl#L32-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.setcolors!"><a class="docstring-binding" href="#StyledStrings.setcolors!"><code>StyledStrings.setcolors!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">setcolors!(colors::Vector{Pair{Symbol, RGBTuple}})</code></pre><p>Update the known base colors with those in <code>colors</code>, and recalculate current faces.</p><p><code>color</code> should be a complete list of known colours. If <code>:foreground</code> and
<code>:background</code> are both specified, the faces in the light/dark theme will be
loaded. Otherwise, only the base theme will be applied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L452-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.face!"><a class="docstring-binding" href="#StyledStrings.face!"><code>StyledStrings.face!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">face!(str::Union{&lt;:AnnotatedString, &lt;:SubString{&lt;:AnnotatedString}},
      [range::UnitRange{Int},] face::Union{Symbol, Face})</code></pre><p>Apply <code>face</code> to <code>str</code>, along <code>range</code> if specified or the whole of <code>str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L295-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.getface"><a class="docstring-binding" href="#StyledStrings.getface"><code>StyledStrings.getface</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getface(faces)</code></pre><p>Obtain the final merged face from <code>faces</code>, an iterator of
<a href="../#StyledStrings.Face"><code>Face</code></a>s, face name <code>Symbol</code>s, and lists thereof.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L243-L248">source</a></section><section><div><pre><code class="language-julia hljs">getface(annotations::Vector{@NamedTuple{label::Symbol, value::Any}})</code></pre><p>Combine all of the <code>:face</code> annotations with <code>getfaces</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L258-L262">source</a></section><section><div><pre><code class="language-julia hljs">getface()</code></pre><p>Obtain the default face.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L271-L275">source</a></section><section><div><pre><code class="language-julia hljs">getface(s::AnnotatedString, i::Integer)</code></pre><p>Get the merged <a href="../#StyledStrings.Face"><code>Face</code></a> that applies to <code>s</code> at index <code>i</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L280-L284">source</a></section><section><div><pre><code class="language-julia hljs">getface(c::AnnotatedChar)</code></pre><p>Get the merged <a href="../#StyledStrings.Face"><code>Face</code></a> that applies to <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L288-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.load_customisations!"><a class="docstring-binding" href="#StyledStrings.load_customisations!"><code>StyledStrings.load_customisations!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_customisations!(; force::Bool=false)</code></pre><p>Load customisations from the user&#39;s <code>faces.toml</code> file, if it exists as well as
the current environment.</p><p>This function should be called before producing any output in situations where
the user&#39;s customisations should be considered. This is called automatically
when printing text or HTML output, and when calling <code>withfaces</code>, but may need
to be called manually in unusual situations.</p><p>Unless <code>force</code> is set, customisations are only applied when this function is
called for the first time, and subsequent calls are a no-op.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/StyledStrings.jl#L24-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.loadface!"><a class="docstring-binding" href="#StyledStrings.loadface!"><code>StyledStrings.loadface!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loadface!(name::Symbol =&gt; update::Face)</code></pre><p>Merge the face <code>name</code> in <code>FACES</code><code>.current</code> with <code>update</code>. If the face <code>name</code>
does not already exist in <code>FACES</code><code>.current</code>, then it is set to <code>update</code>. To
reset a face, <code>update</code> can be set to <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; loadface!(:red =&gt; Face(foreground=0xff0000))
Face (sample)
    foreground: #ff0000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L311-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.loaduserfaces!"><a class="docstring-binding" href="#StyledStrings.loaduserfaces!"><code>StyledStrings.loaduserfaces!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">loaduserfaces!(faces::Dict{String, Any})</code></pre><p>For each face specified in <code>Dict</code>, load it to <code>FACES</code><code>.current</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L346-L350">source</a></section><section><div><pre><code class="language-julia hljs">loaduserfaces!(tomlfile::String)</code></pre><p>Load all faces declared in the Faces.toml file <code>tomlfile</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L369-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.resetfaces!"><a class="docstring-binding" href="#StyledStrings.resetfaces!"><code>StyledStrings.resetfaces!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">resetfaces!()</code></pre><p>Reset the current global face dictionary to the default value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L146-L150">source</a></section><section><div><pre><code class="language-julia hljs">resetfaces!(name::Symbol)</code></pre><p>Reset the face <code>name</code> to its default value, which is returned.</p><p>If the face <code>name</code> does not exist, nothing is done and <code>nothing</code> returned.
In the unlikely event that the face <code>name</code> does not have a default value,
it is deleted, a warning message is printed, and <code>nothing</code> returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L165-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.rgbcolor"><a class="docstring-binding" href="#StyledStrings.rgbcolor"><code>StyledStrings.rgbcolor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rgbcolor(color::Union{Symbol, SimpleColor})</code></pre><p>Resolve a <code>color</code> to an <code>RGBTuple</code>.</p><p>The resolution follows these steps:</p><ol><li>If <code>color</code> is a <code>SimpleColor</code> holding an <code>RGBTuple</code>, that is returned.</li><li>If <code>color</code> names a face, the face&#39;s foreground color is used.</li><li>If <code>color</code> names a base color, that color is used.</li><li>Otherwise, <code>UNRESOLVED_COLOR_FALLBACK</code> (bright pink) is returned.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L547-L557">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.termcolor"><a class="docstring-binding" href="#StyledStrings.termcolor"><code>StyledStrings.termcolor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">termcolor(io::IO, color::SimpleColor, category::Char)</code></pre><p>Print to <code>io</code> the SGR code to set the <code>category</code>&#39;s slot to <code>color</code>,
where <code>category</code> is set as follows:</p><ul><li><p><code>&#39;3&#39;</code> sets the foreground color</p></li><li><p><code>&#39;4&#39;</code> sets the background color</p></li><li><p><code>&#39;5&#39;</code> sets the underline color</p></li></ul><p>If <code>color</code> is a <code>SimpleColor{Symbol}</code>, the value should be a a member of
<code>ANSI_4BIT_COLORS</code>. Any other value will cause the color to be reset.</p><p>If <code>color</code> is a <code>SimpleColor{RGBTuple}</code> and <code>get_have_truecolor()</code> returns true,
24-bit color is used. Otherwise, an 8-bit approximation of <code>color</code> is used.</p><p>If <code>color</code> is unknown, no output is produced.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/io.jl#L95-L111">source</a></section><section><div><pre><code class="language-julia hljs">termcolor(io::IO, ::Nothing, category::Char)</code></pre><p>Print to <code>io</code> the SGR code to reset the color for <code>category</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/io.jl#L150-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.termcolor24bit"><a class="docstring-binding" href="#StyledStrings.termcolor24bit"><code>StyledStrings.termcolor24bit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">termcolor24bit(io::IO, color::RGBTuple, category::Char)</code></pre><p>Print to <code>io</code> the 24-bit SGR color code to set the <code>category</code>8 slot to <code>color</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/io.jl#L83-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.termcolor8bit"><a class="docstring-binding" href="#StyledStrings.termcolor8bit"><code>StyledStrings.termcolor8bit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">termcolor8bit(io::IO, color::RGBTuple, category::Char)</code></pre><p>Print to <code>io</code> the best 8-bit SGR color code that sets the <code>category</code> color to
be close to <code>color</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/io.jl#L46-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.try_rgbcolor"><a class="docstring-binding" href="#StyledStrings.try_rgbcolor"><code>StyledStrings.try_rgbcolor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">try_rgbcolor(name::Symbol, stamina::Int = MAX_COLOR_FORWARDS)</code></pre><p>Attempt to resolve <code>name</code> to an <code>RGBTuple</code>, taking up to <code>stamina</code> steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/theme.jl#L525-L529">source</a></section></details></article><h2 id="Styled-Markup-parsing"><a class="docs-heading-anchor" href="#Styled-Markup-parsing">Styled Markup parsing</a><a id="Styled-Markup-parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Styled-Markup-parsing" title="Permalink"></a></h2><p>While some of the internals above are useful outside <code>StyledStrings</code>, and
unlikely to be broken (but with no guarantees!), apart from the exported string
macro and <code>styled</code> function, the details of <code>StyledMarkup</code> documented below
consists entirely of implementation details that should under no circumstances
be referenced outside of <code>StyledStrings</code> .</p><p>If you&#39;re curious about how exactly styled markup strings are parsed, they
should provide some insight though.</p><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup"><a class="docstring-binding" href="#StyledStrings.StyledMarkup"><code>StyledStrings.StyledMarkup</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">StyledMarkup</code></pre><p>A sub-module of <code>StyledStrings</code> that specifically deals with parsing styled
markup strings. To this end, two entrypoints are provided:</p><ul><li><p>The <a href="../#StyledStrings.StyledMarkup.@styled_str"><code>styled&quot;&quot;</code></a> string macro, which is generally preferred.</p></li><li><p>They <a href="../#StyledStrings.StyledMarkup.styled"><code>styled</code></a> function, which allows for use with runtime-provided strings,
when needed.</p></li></ul><p>Overall, this module essentially functions as a state machine with a few extra
niceties (like detailed error reporting) sprinkled on top. The overall design
can be largely summed up with the following diagram:</p><pre><code class="language-text hljs">╭String─────────╮
│ Styled markup │
╰──────┬────────╯
       │╭╴[module]
       ││
      ╭┴┴State─╮
      ╰┬───────╯
       │
 ╭╴run_state_machine!╶╮
 │              ╭─────┼─╼ escaped!
 │ Apply rules: │     │
 │  &quot;\\&quot; ▶──────╯ ╭───┼─╼[interpolated!] ──▶ readexpr!, addpart!
 │  &quot;$&quot; ▶────────╯   │
 │  &quot;{&quot;  ▶────────────┼─╼ begin_style! ──▶ read_annotation!
 │  &quot;}&quot;  ▶─────╮      │                     ├─╼ read_inlineface! [readexpr!]
 │             ╰──────┼─╼ end_style!        ╰─╼ read_face_or_keyval!
 │ addpart!(...)      │
 ╰╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╯
       │
       ▼
     Result</code></pre><p>Of course, as usual, the devil is in the details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L6-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.State"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.State"><code>StyledStrings.StyledMarkup.State</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">State</code></pre><p>A struct representing of the parser state (if you squint, a state monad even).</p><p>To create the initial state, use the constructor:
    State(content::AbstractString, mod::Union{Module, Nothing}=nothing) -&gt; State</p><p>Its fields are as follows:</p><ul><li><code>content::String</code>, the (unescaped) input string</li><li><code>bytes::Vector{UInt8}</code>, the codeunits of <code>content</code>. This is a <code>Vector{UInt8}</code> instead of a
<code>CodeUnits{UInt8}</code> because we need to be able to modify the array, for instance when erasing
escape characters.</li><li><code>s::Iterators.Stateful</code>, an <code>(index, char)</code> iterator of <code>content</code></li><li><code>mod::Union{Module, Nothing}</code>, the (optional) context with which to evaluate inline
expressions in. This should be provided iff the styled markup comes from a macro invocation.</li><li><code>parts::Vector{Any}</code>, the result of the parsing, a list of elements that when passed to
<code>annotatedstring</code> produce the styled markup string. The types of its values are highly diverse,
hence the <code>Any</code> element type.</li><li><code>active_styles::Vector{Vector{Tuple{Int, Int, Union{Symbol, Expr, Tuple{Symbol, Any}}}}}}</code>,
A list of batches of styles that have yet to be applied to any content. Entries of a batch
consist of <code>(source_position, start_position, style)</code> tuples, where <code>style</code> may be just
a symbol (referring to a face), a <code>Tuple{Symbol, Any}</code> annotation, or an <code>Expr</code> that evaluates
to a valid annotation (when <code>mod</code> is set).</li><li><code>pending_styles::Vector{Tuple{UnitRange{Int}, Union{Symbol, Expr, Tuple{Symbol, Any}}}}</code>,
A list of styles that have been terminated, and so are known to occur over a certain range,
but have yet to be applied.</li><li><code>offset::Int</code>, a record of the between the <code>content</code> index and the index in the resulting
styled string, as markup structures are absorbed.</li><li><code>point::Int</code>, the current index in <code>content</code>.</li><li><code>escape::Bool</code>, whether the last character seen was an escape character.</li><li><code>interpolations::Int</code>, how many interpolated values have been seen. Knowing whether or not
anything needs to be evaluated allows the resulting string to be computed at macroexpansion time,
when possible, and knowing how many allows for some micro-optimisations.</li><li><code>errors::Vector</code>, any errors raised during parsing. We collect them instead of immediately throwing
so that we can list as many issues as possible at once, instead of forcing the author of the invalid
styled markup to resolve each issue one at a time. This is expected to be populated by invocations of
<code>styerr!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L53-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.isnextchar"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.isnextchar"><code>StyledStrings.StyledMarkup.isnextchar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isnextchar(state::State, char::Char) -&gt; Bool
isnextchar(state::State, chars::NTuple{N, Char}) -&gt; Bool</code></pre><p>Check if <code>state</code> has a next character, and if so whether it is <code>char</code> or one of <code>chars</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L128-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.ismacro"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.ismacro"><code>StyledStrings.StyledMarkup.ismacro</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ismacro(state::State) -&gt; Bool</code></pre><p>Check whether <code>state</code> is indicated to come from a macro invocation,
according to whether <code>state.mod</code> is set or not.</p><p>While this function is rather trivial, it clarifies the intent when used instead
of just checking <code>state.mod</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L142-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.styerr!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.styerr!"><code>StyledStrings.StyledMarkup.styerr!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">styerr!(state::State, message::AbstractString, position::Union{Nothing, Int}=nothing, hint::String=&quot;around here&quot;)</code></pre><p>Register an error in <code>state</code> based on erroneous content at or around <code>position</code>
(if known, and with a certain <code>hint</code> as to the location), with the nature of the
error given by <code>message</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L153-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.hygienic_eval"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.hygienic_eval"><code>StyledStrings.StyledMarkup.hygienic_eval</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hygienic_eval(state::State, expr)</code></pre><p>Evaluate <code>expr</code> within the scope of <code>state</code>&#39;s module.
This replicates part of the behind-the-scenes behaviour of macro expansion, we
just need to manually invoke it due to the particularities around dealing with
code from a foreign module that we parse ourselves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L175-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.addpart!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.addpart!"><code>StyledStrings.StyledMarkup.addpart!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">addpart!(state::State, stop::Int)</code></pre><p>Create a new part from <code>state.point</code> to <code>stop</code>, applying all pending styles.</p><p>This consumes all the content between <code>state.point</code> and  <code>stop</code>, and shifts
<code>state.point</code> to be the index after <code>stop</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L186-L193">source</a></section><section><div><pre><code class="language-julia hljs">addpart!(state::State, start::Int, expr, stop::Int)</code></pre><p>Create a new part based on (the eventual evaluation of) <code>expr</code>, running from
<code>start</code> to <code>stop</code>, taking the currently active styles into account.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L237-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.escaped!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.escaped!"><code>StyledStrings.StyledMarkup.escaped!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">escaped!(state::State, i::Int, char::Char)</code></pre><p>Parse the escaped character <code>char</code>, at index <code>i</code>, into <code>state</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L281-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.interpolated!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.interpolated!"><code>StyledStrings.StyledMarkup.interpolated!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">interpolated!(state::State, i::Int, _)</code></pre><p>Interpolate the expression starting at <code>i</code>, and add it as a part to <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L306-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.readexpr!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.readexpr!"><code>StyledStrings.StyledMarkup.readexpr!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">readexpr!(state::State, pos::Int = first(popfirst!(state.s)) + 1)</code></pre><p>Read the expression starting at <code>pos</code> in <code>state.content</code>, and consume <code>state.s</code>
as appropriate to align the iterator to the end of the expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L320-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.skipwhitespace!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.skipwhitespace!"><code>StyledStrings.StyledMarkup.skipwhitespace!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">skipwhitespace!(state::State)</code></pre><p>Skip forwards all space, tab, and newline characters in <code>state.s</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L343-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.read_while!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.read_while!"><code>StyledStrings.StyledMarkup.read_while!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_while!(f::Function, state::Base.Stateful, lastchar::Char)</code></pre><p>Read <code>state</code> until <code>f(::Char)</code> is <code>false</code>.</p><p>Given a <code>Stateful</code> that iterates <code>(_, char::Char)</code> pairs, and a predicate
<code>f(::Char)::Bool</code>, return <code>(str, lastchar)</code>, where <code>str::String</code> contains all the
<code>char</code> for which <code>f(char) == true</code>, and <code>lastchar</code> the last <code>char</code> element seen,
or the input <code>lastchar</code> there are no elements of <code>state</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; s = Base.Stateful(pairs(&quot;abc&quot;));

julia&gt; read_while!(isnumeric, s, &#39;w&#39;)
(&quot;&quot;, &#39;a&#39;)

julia&gt; first(s) # s is mutated
2 =&gt; &#39;b&#39;

julia&gt; read_while!(isascii, Base.Stateful(pairs(&quot;123Σω&quot;)), &#39;k&#39;)
(&quot;123&quot;, &#39;Σ&#39;)

julia&gt; read_while!(isascii, Base.Stateful(pairs(&quot;abcde&quot;)), &#39;α&#39;)
(&quot;abcde&quot;, &#39;e&#39;)

julia&gt; read_while!(isascii , Base.Stateful(pairs(&quot;&quot;)), &#39;k&#39;)
(&quot;&quot;, &#39;k&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L354-L384">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.begin_style!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.begin_style!"><code>StyledStrings.StyledMarkup.begin_style!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">begin_style!(state::State, i::Int, char::Char)</code></pre><p>Parse the style declaration beginning at <code>i</code> (<code>char</code>) with <code>read_annotation!</code>,
and register it in the active styles list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L398-L403">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.end_style!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.end_style!"><code>StyledStrings.StyledMarkup.end_style!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">end_style!(state::State, i::Int, char::Char)</code></pre><p>Close of the most recent active style in <code>state</code>, making it a pending style.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L419-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.read_annotation!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.read_annotation!"><code>StyledStrings.StyledMarkup.read_annotation!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_annotation!(state::State, i::Int, char::Char, newstyles::Vector) -&gt; Bool</code></pre><p>Read the annotations at <code>i</code> (<code>char</code>), and push the style read to <code>newstyles</code>.</p><p>This skips whitespace and checks what the next character in <code>state.s</code> is,
detects the form of the annotation, and parses it using the appropriate
specialised function like so:</p><ul><li><p><code>:</code>, end of annotation, do nothing</p></li><li><p><code>(</code>, inline face declaration, use <code>read_inlineface!</code></p></li><li><p>otherwise, use <code>read_face_or_keyval!</code></p></li></ul><p>After parsing the annotation, returns a boolean value signifying whether there
is an immediately subsequent annotation to be read.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L432-L446">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.read_inlineface!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.read_inlineface!"><code>StyledStrings.StyledMarkup.read_inlineface!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_inlineface!(state::State, i::Int, char::Char, newstyles)</code></pre><p>Read an inline face declaration from <code>state</code>, at position <code>i</code> (<code>char</code>), and add
it to <code>newstyles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L480-L485">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.read_face_or_keyval!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.read_face_or_keyval!"><code>StyledStrings.StyledMarkup.read_face_or_keyval!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_face_or_keyval!(state::State, i::Int, char::Char, newstyles)</code></pre><p>Read an inline face or key-value pair from <code>state</code> at position <code>i</code> (<code>char</code>), and
add it to <code>newstyles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L742-L747">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.run_state_machine!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.run_state_machine!"><code>StyledStrings.StyledMarkup.run_state_machine!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">run_state_machine!(state::State)</code></pre><p>Iterate through <code>state.s</code>, applying the parsing rules for the top-level of
syntax and calling the relevant specialised functions.</p><p>Upon completion, <code>state.s</code> should be fully consumed and <code>state.parts</code> fully
populated (along with <code>state.errors</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L830-L838">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StyledStrings.StyledMarkup.annotatedstring_optimize!"><a class="docstring-binding" href="#StyledStrings.StyledMarkup.annotatedstring_optimize!"><code>StyledStrings.StyledMarkup.annotatedstring_optimize!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">annotatedstring_optimize!(str::AnnotatedString)</code></pre><p>Merge contiguous identical annotations in <code>str</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/StyledStrings.jl/blob/51470b3ef62e106889948aa4fd8d768d1910021c/src/styledmarkup.jl#L869-L873">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Example Usage</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 10 February 2026 16:38">Tuesday 10 February 2026</span>. Using Julia version 1.14.0-DEV.1702.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
