var documenterSearchIndex = {"docs":
[{"title":"Usage Examples","page":"Example Usage","location":"examples/#Usage-Examples","category":"section","text":"info: Visual inconsistencies\nThere are some examples on this page that don't quite look as they should, see Documenter.jl#2488 for more information and potential improvements to this situation.\n\nWith flexibility and composability as major considerations in the design of\nStyledStrings, it is easy to describe the capabilities of this system while\nfailing to actually convey what it can accomplish. With this in mind, examples\ncan be particularly useful to show how it can be used.\n\nA styled string can be constructed manually, but the [styled\"...\"](@ref\n@styled_str) literal is almost always a nicer option. We can see what a manual construction would involve by extracting the string and annotation parts of a AnnotatedString.\n\nusing StyledStrings\nstr = styled\"{yellow:hello} {blue:there}\"\n(String(str), annotations(str))\n\nMost of the examples here will show AnnotatedString in a terminal/REPL context, however they can be trivially adapted to produce HTML with show(::IO, ::MIME\"text/plain\", ::AnnotatedString), and other packages wanting do deal with styled content in other contexts will likely find integration with StyledStrings worthwhile."},{"title":"Basic face application and colouring","page":"Example Usage","location":"examples/#Basic-face-application-and-colouring","category":"section","text":"As an end-user or a package-author, adding color is one of if not the most frequent application of styling. The default set of colors has the eight ANSI colors, and if we're to be brutally honest, black/white are just shades, leaving us with:\n\nstyled\"{red:■} {green:■} {yellow:■} {blue:■} {magenta:■} {cyan:■}\"\n\nalong with \"bright\"  variants\n\nstyled\"{bright_red:■} {bright_green:■} {bright_yellow:■} \\\n       {bright_blue:■} {bright_magenta:■} {bright_cyan:■}\""},{"title":"Adding new faces","page":"Example Usage","location":"examples/#Adding-new-faces","category":"section","text":"This seems somewhat limited, because it is. This is only the default set of\ncolors though. It is important to note that the way the color red is\nimplemented is by having it name a Face(foreground=:red) value. The ANSI\nprinter knows to handle the ANSI named colors specially, but you can create\nmore \"named colors\" simply by adding new faces.\n\nStyledStrings.addface!(:orange => StyledStrings.Face(foreground = 0xFF7700))\nstyled\"{orange:this is orange text}\"\n\nwarning: Appropriate face naming\nThe face name orange is used here as an example, but this would be\ninappropriate for a package to introduce as it's missing the packagename_\nprefix. This is important for predictability, and to prevent name clashes.\n\nThe fact that named colors are implemented this way also allows for other nice\nconveniences. For example, if you wanted a more subtle version of the warning\nstyling, you could print text with the underline color set to the warning\nforeground color.\n\nstyled\"{(underline=warning):this is some minor/slight warning text}\"\nstyled\"A very major {(fg=error,bg=warning),bold:warning!}\"\n\ntip: Focus on semantics, and let style follow\nNote that when using faces, it is generally recommended to focus on the\nsemantic intent, not the specific styling (cyan, bold, etc.),\nintroducing new faces when there is no pre-existing semantically appropriate\nface."},{"title":"Inline face attributes","page":"Example Usage","location":"examples/#Inline-face-attributes","category":"section","text":"Should you want to use a particular color just once, the foreground/fg and background/bg inline face attributes can be set to hex codes.\n\nstyled\"{(fg=#4063d8):ju}{(fg=#389826):l}{(fg=#cb3c33):i}{(fg=#9558b2):a}\"\n\nThis works just as well with named colours.\n\nstyled\"Since {orange:orange} is a face with a foreground, \\\n       you can use it as a {(fg=orange):foreground color}.\"\n\nAll the other Face attributes can be set similarly."},{"title":"Considerations when creating and reusing faces","page":"Example Usage","location":"examples/#Considerations-when-creating-and-reusing-faces","category":"section","text":"It is recommended that package authors create faces with a focus on the semantic\nmeaning they wish to impart, and then consider what styling suits. For example,\nsay that a hypothetical package foobar wants to mark something as important.\nCreating a named face allows for it to be re-used across the codebase and allows\nthe styling everywhere its used to be updated by only changing the line\ndeclaring it. foobar_important would be an appropriate name for such a face.\n\nStyledStrings.addface!(:foobar_important => StyledStrings.Face(weight = :bold, inherit = :emphasis))\nstyled\"this is some {foobar_important:rather important} content\"\n\nOther packages that interact with foobar can also re-use the\nfoobar_important face for consistent styling. This is possible even for\npackages that don't have foobar as a direct dependency, as faces that don't\nexist are just ignored. Consider this styled content as an example:\n\nstyled\"{info,foobar_important,baz_important:some text}\"\n\nThe styling of \"some text\" will be based only on info if neither\nfoobar_important or baz_important are defined. Since foobar_important is\ndefined, after applying the attributes of info, the attributes of\nfoobar_important are applied to \"some text\" overwriting any attributes set\nby info. Should bar_important be defined in the future, any attributes it\nsets will override foobar_important and info. Put more simply, the last face\nmentioned \"wins\".\n\nnote: Note\nThe silent ignoring of undefined faces is important in making it so that it's known if a styled\"...\" string will cause errors when printed is known at compile-time instead of runtime."},{"title":"User-customisation of faces","page":"Example Usage","location":"examples/#User-customisation-of-faces","category":"section","text":"Naming faces also allows for convenient customisation. Once foobar_important\nis defined, a user can change how it is styled in their faces.toml.\n\n[foobar.important]\nitalic = true\n\nnote: Accessibility\nUser-customisation is particularly important when using color, as it allows people with color-blindness or other neuro-ophthalmological abnormalities to make text easier to read/distinguish."},{"title":"Application-customisation of faces","page":"Example Usage","location":"examples/#Application-customisation-of-faces","category":"section","text":"Named faces can also be customised on-the-fly in certain printing contexts created by withfaces.\n\nStyledStrings.withfaces(:foobar_important => :tip) do\n    println(styled\"Sometimes you might want {foobar_important:some text} to look different\")\nend\nStyledStrings.withfaces(:log_info => [:magenta, :italic]) do\n    @info \"Hello there\"\nend\n\nThis feature can be used to for example change the default colors to follow a\ncertain color theme when generating HTML output.\n\nStyledStrings.withfaces(:green => StyledStrings.Face(foreground = 0xb7ba25),\n                        :yellow => StyledStrings.Face(foreground = 0xfabc2e),\n                        :magenta => StyledStrings.Face(foreground = 0xd2859a)) do\n    str = styled\"Sometimes you might want {green:different} {yellow:shades} of {magenta:colors}.\"\n    println(str, \"\\n\")\n    show(stdout, MIME(\"text/html\"), str)\nend"},{"title":"Composing and interpolating styled content","page":"Example Usage","location":"examples/#Composing-and-interpolating-styled-content","category":"section","text":"As you work with more styled content, the ability to compose styled content and\nstyling information is rather useful. Helpfully, StyledStrings allows for\ninterpolation of both content and attributes.\n\nsmall_rainbow = (:red, :yellow, :green, :blue, :magenta)\ncolor = join([styled\"{$f:$c}\" for (f, c) in tuple.(small_rainbow, collect(\"color\"))])\nstyled\"It's nice to include $color, and it composes too: {bold,inverse:$color}\"\n\nSometimes it's useful to compose a string incrementally, or interoperate with\nother IO-based code. For these use-cases, the AnnotatedIOBuffer is very handy, as you can read an AnnotatedString from it.\n\naio = AnnotatedIOBuffer()\ntyp = Int\nprint(aio, typ)\nwhile typ != Any # We'll pretend that `supertypes` doesn't exist.\n    typ = supertype(typ)\n    print(aio, styled\" {bright_red:<:} $typ\")\nend\nread(seekstart(aio), AnnotatedString)\n\nStyledStrings adds a specialised printstyled method printstyled(::AnnotatedIOBuffer, ...) that means that you can pass an AnnotatedIOBuffer as IO to \"legacy\" code written to use printstyled, and extract all the styling as though it had used styled\"...\" macros.\n\naio = AnnotatedIOBuffer()\nprintstyled(aio, 'c', color=:red)\nprintstyled(aio, 'o', color=:yellow)\nprintstyled(aio, 'l', color=:green)\nprintstyled(aio, 'o', color=:blue)\nprintstyled(aio, 'r', color=:magenta)\nread(seekstart(aio), AnnotatedString)\nread(seekstart(aio), String)"},{"title":"Internals","page":"Internals","location":"internals/#Internals","category":"section","text":"Everything documented in this page is internal and subject to breaking changes,\neven in minor version updates of Julia or StyledStrings.jl. If you are curious\nabout the internals, read on, but if you want to depend on them, please consider\nopening a pull request or issue to discuss making them part of the public API."},{"title":"Styled Markup parsing","page":"Internals","location":"internals/#Styled-Markup-parsing","category":"section","text":"While some of the internals above are useful outside StyledStrings, and\nunlikely to be broken (but with no guarantees!), apart from the exported string\nmacro and styled function, the details of StyledMarkup documented below\nconsists entirely of implementation details that should under no circumstances\nbe referenced outside of StyledStrings .\n\nIf you're curious about how exactly styled markup strings are parsed, they\nshould provide some insight though."},{"title":"StyledStrings.ANSI_4BIT_COLORS","page":"Internals","location":"internals/#StyledStrings.ANSI_4BIT_COLORS","category":"constant","text":"A mapping between ANSI named colours and indices in the standard 256-color\ntable. The standard colors are 0-7, and high intensity colors 8-15.\n\nThe high intensity colors are prefixed by \"bright\". The \"brightblack\" color is\ngiven two aliases: \"grey\" and \"gray\".\n\n\n\n\n\n"},{"title":"StyledStrings.FACES","page":"Internals","location":"internals/#StyledStrings.FACES","category":"constant","text":"Globally named Faces.\n\ndefault gives the initial values of the faces, and current holds the active\n(potentially modified) set of faces. This two-set system allows for any\nmodifications to the active faces to be undone.\n\n\n\n\n\n"},{"title":"StyledStrings.MAX_COLOR_FORWARDS","page":"Internals","location":"internals/#StyledStrings.MAX_COLOR_FORWARDS","category":"constant","text":"MAX_COLOR_FORWARDS\n\nThe maximum number of times to follow color references when resolving a color.\n\n\n\n\n\n"},{"title":"StyledStrings.UNRESOLVED_COLOR_FALLBACK","page":"Internals","location":"internals/#StyledStrings.UNRESOLVED_COLOR_FALLBACK","category":"constant","text":"UNRESOLVED_COLOR_FALLBACK\n\nThe fallback RGBTuple used when asking for a color that is not defined.\n\n\n\n\n\n"},{"title":"StyledStrings.Legacy.ANSI_256_COLORS","page":"Internals","location":"internals/#StyledStrings.Legacy.ANSI_256_COLORS","category":"constant","text":"A mapping from 256-color codes indicies to 8-bit colours.\n\n\n\n\n\n"},{"title":"StyledStrings.Legacy.NAMED_COLORS","page":"Internals","location":"internals/#StyledStrings.Legacy.NAMED_COLORS","category":"constant","text":"A list of all named colors recognised, including both the old light_* and new\nbright_* named colors.\n\n\n\n\n\n"},{"title":"StyledStrings.Legacy.RENAMED_COLORS","page":"Internals","location":"internals/#StyledStrings.Legacy.RENAMED_COLORS","category":"constant","text":"A mapping from old named colours to the new names, specifically from light_*\nto bright_*.\n\n\n\n\n\n"},{"title":"StyledStrings.Legacy.legacy_color","page":"Internals","location":"internals/#StyledStrings.Legacy.legacy_color","category":"function","text":"legacy_color(color::Union{String, Symbol, Int})\n\nAttempt to obtain a SimpleColor for a \"legacy\" color value color.\n\nWhen this is not possible, nothing is returned.\n\n\n\n\n\n"},{"title":"StyledStrings.Legacy.load_env_colors!","page":"Internals","location":"internals/#StyledStrings.Legacy.load_env_colors!","category":"function","text":"load_env_colors!()\n\nTry to emulate the effect of the various *_color() functions of Base, by\nloading any specified colours as foregrounds of the relevant faces.\n\n\n\n\n\n"},{"title":"StyledStrings.ansi_4bit","page":"Internals","location":"internals/#StyledStrings.ansi_4bit","category":"function","text":"ansi_4bit(color::Integer, background::Bool=false)\n\nProvide the color code (30-37, 40-47, 90-97, 100-107) for color (0–15).\n\nWhen background is set the background variant will be provided, otherwise\nthe provided code is for setting the foreground color.\n\n\n\n\n\n"},{"title":"StyledStrings.setcolors!","page":"Internals","location":"internals/#StyledStrings.setcolors!","category":"function","text":"setcolors!(colors::Vector{Pair{Symbol, RGBTuple}})\n\nUpdate the known base colors with those in colors, and recalculate current faces.\n\ncolor should be a complete list of known colours. If :foreground and\n:background are both specified, the faces in the light/dark theme will be\nloaded. Otherwise, only the base theme will be applied.\n\n\n\n\n\n"},{"title":"StyledStrings.face!","page":"Internals","location":"internals/#StyledStrings.face!","category":"function","text":"face!(str::Union{<:AnnotatedString, <:SubString{<:AnnotatedString}},\n      [range::UnitRange{Int},] face::Union{Symbol, Face})\n\nApply face to str, along range if specified or the whole of str.\n\n\n\n\n\n"},{"title":"StyledStrings.getface","page":"Internals","location":"internals/#StyledStrings.getface","category":"function","text":"getface(faces)\n\nObtain the final merged face from faces, an iterator of\nFaces, face name Symbols, and lists thereof.\n\n\n\n\n\ngetface(annotations::Vector{@NamedTuple{label::Symbol, value::Any}})\n\nCombine all of the :face annotations with getfaces.\n\n\n\n\n\ngetface()\n\nObtain the default face.\n\n\n\n\n\ngetface(s::AnnotatedString, i::Integer)\n\nGet the merged Face that applies to s at index i.\n\n\n\n\n\ngetface(c::AnnotatedChar)\n\nGet the merged Face that applies to c.\n\n\n\n\n\n"},{"title":"StyledStrings.load_customisations!","page":"Internals","location":"internals/#StyledStrings.load_customisations!","category":"function","text":"load_customisations!(; force::Bool=false)\n\nLoad customisations from the user's faces.toml file, if it exists as well as\nthe current environment.\n\nThis function should be called before producing any output in situations where\nthe user's customisations should be considered. This is called automatically\nwhen printing text or HTML output, and when calling withfaces, but may need\nto be called manually in unusual situations.\n\nUnless force is set, customisations are only applied when this function is\ncalled for the first time, and subsequent calls are a no-op.\n\n\n\n\n\n"},{"title":"StyledStrings.loadface!","page":"Internals","location":"internals/#StyledStrings.loadface!","category":"function","text":"loadface!(name::Symbol => update::Face)\n\nMerge the face name in FACES.current with update. If the face name\ndoes not already exist in FACES.current, then it is set to update. To\nreset a face, update can be set to nothing.\n\nExamples\n\njulia> loadface!(:red => Face(foreground=0xff0000))\nFace (sample)\n    foreground: #ff0000\n\n\n\n\n\n"},{"title":"StyledStrings.loaduserfaces!","page":"Internals","location":"internals/#StyledStrings.loaduserfaces!","category":"function","text":"loaduserfaces!(faces::Dict{String, Any})\n\nFor each face specified in Dict, load it to FACES.current.\n\n\n\n\n\nloaduserfaces!(tomlfile::String)\n\nLoad all faces declared in the Faces.toml file tomlfile.\n\n\n\n\n\n"},{"title":"StyledStrings.resetfaces!","page":"Internals","location":"internals/#StyledStrings.resetfaces!","category":"function","text":"resetfaces!()\n\nReset the current global face dictionary to the default value.\n\n\n\n\n\nresetfaces!(name::Symbol)\n\nReset the face name to its default value, which is returned.\n\nIf the face name does not exist, nothing is done and nothing returned.\nIn the unlikely event that the face name does not have a default value,\nit is deleted, a warning message is printed, and nothing returned.\n\n\n\n\n\n"},{"title":"StyledStrings.rgbcolor","page":"Internals","location":"internals/#StyledStrings.rgbcolor","category":"function","text":"rgbcolor(color::Union{Symbol, SimpleColor})\n\nResolve a color to an RGBTuple.\n\nThe resolution follows these steps:\n\nIf color is a SimpleColor holding an RGBTuple, that is returned.\nIf color names a face, the face's foreground color is used.\nIf color names a base color, that color is used.\nOtherwise, UNRESOLVED_COLOR_FALLBACK (bright pink) is returned.\n\n\n\n\n\n"},{"title":"StyledStrings.termcolor","page":"Internals","location":"internals/#StyledStrings.termcolor","category":"function","text":"termcolor(io::IO, color::SimpleColor, category::Char)\n\nPrint to io the SGR code to set the category's slot to color,\nwhere category is set as follows:\n\n'3' sets the foreground color\n'4' sets the background color\n'5' sets the underline color\n\nIf color is a SimpleColor{Symbol}, the value should be a a member of\nANSI_4BIT_COLORS. Any other value will cause the color to be reset.\n\nIf color is a SimpleColor{RGBTuple} and get_have_truecolor() returns true,\n24-bit color is used. Otherwise, an 8-bit approximation of color is used.\n\nIf color is unknown, no output is produced.\n\n\n\n\n\ntermcolor(io::IO, ::Nothing, category::Char)\n\nPrint to io the SGR code to reset the color for category.\n\n\n\n\n\n"},{"title":"StyledStrings.termcolor24bit","page":"Internals","location":"internals/#StyledStrings.termcolor24bit","category":"function","text":"termcolor24bit(io::IO, color::RGBTuple, category::Char)\n\nPrint to io the 24-bit SGR color code to set the category8 slot to color.\n\n\n\n\n\n"},{"title":"StyledStrings.termcolor8bit","page":"Internals","location":"internals/#StyledStrings.termcolor8bit","category":"function","text":"termcolor8bit(io::IO, color::RGBTuple, category::Char)\n\nPrint to io the best 8-bit SGR color code that sets the category color to\nbe close to color.\n\n\n\n\n\n"},{"title":"StyledStrings.try_rgbcolor","page":"Internals","location":"internals/#StyledStrings.try_rgbcolor","category":"function","text":"try_rgbcolor(name::Symbol, stamina::Int = MAX_COLOR_FORWARDS)\n\nAttempt to resolve name to an RGBTuple, taking up to stamina steps.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup","page":"Internals","location":"internals/#StyledStrings.StyledMarkup","category":"module","text":"StyledMarkup\n\nA sub-module of StyledStrings that specifically deals with parsing styled\nmarkup strings. To this end, two entrypoints are provided:\n\nThe styled\"\" string macro, which is generally preferred.\nThey styled function, which allows for use with runtime-provided strings,\nwhen needed.\n\nOverall, this module essentially functions as a state machine with a few extra\nniceties (like detailed error reporting) sprinkled on top. The overall design\ncan be largely summed up with the following diagram:\n\n╭String─────────╮\n│ Styled markup │\n╰──────┬────────╯\n       │╭╴[module]\n       ││\n      ╭┴┴State─╮\n      ╰┬───────╯\n       │\n ╭╴run_state_machine!╶╮\n │              ╭─────┼─╼ escaped!\n │ Apply rules: │     │\n │  \"\\\\\" ▶──────╯ ╭───┼─╼[interpolated!] ──▶ readexpr!, addpart!\n │  \"$\" ▶────────╯   │\n │  \"{\"  ▶────────────┼─╼ begin_style! ──▶ read_annotation!\n │  \"}\"  ▶─────╮      │                     ├─╼ read_inlineface! [readexpr!]\n │             ╰──────┼─╼ end_style!        ╰─╼ read_face_or_keyval!\n │ addpart!(...)      │\n ╰╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╯\n       │\n       ▼\n     Result\n\nOf course, as usual, the devil is in the details.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.State","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.State","category":"type","text":"State\n\nA struct representing of the parser state (if you squint, a state monad even).\n\nTo create the initial state, use the constructor:\n    State(content::AbstractString, mod::Union{Module, Nothing}=nothing) -> State\n\nIts fields are as follows:\n\ncontent::String, the (unescaped) input string\nbytes::Vector{UInt8}, the codeunits of content. This is a Vector{UInt8} instead of a\nCodeUnits{UInt8} because we need to be able to modify the array, for instance when erasing\nescape characters.\ns::Iterators.Stateful, an (index, char) iterator of content\nmod::Union{Module, Nothing}, the (optional) context with which to evaluate inline\nexpressions in. This should be provided iff the styled markup comes from a macro invocation.\nparts::Vector{Any}, the result of the parsing, a list of elements that when passed to\nannotatedstring produce the styled markup string. The types of its values are highly diverse,\nhence the Any element type.\nactive_styles::Vector{Vector{Tuple{Int, Int, Union{Symbol, Expr, Tuple{Symbol, Any}}}}}},\nA list of batches of styles that have yet to be applied to any content. Entries of a batch\nconsist of (source_position, start_position, style) tuples, where style may be just\na symbol (referring to a face), a Tuple{Symbol, Any} annotation, or an Expr that evaluates\nto a valid annotation (when mod is set).\npending_styles::Vector{Tuple{UnitRange{Int}, Union{Symbol, Expr, Tuple{Symbol, Any}}}},\nA list of styles that have been terminated, and so are known to occur over a certain range,\nbut have yet to be applied.\noffset::Int, a record of the between the content index and the index in the resulting\nstyled string, as markup structures are absorbed.\npoint::Int, the current index in content.\nescape::Bool, whether the last character seen was an escape character.\ninterpolations::Int, how many interpolated values have been seen. Knowing whether or not\nanything needs to be evaluated allows the resulting string to be computed at macroexpansion time,\nwhen possible, and knowing how many allows for some micro-optimisations.\nerrors::Vector, any errors raised during parsing. We collect them instead of immediately throwing\nso that we can list as many issues as possible at once, instead of forcing the author of the invalid\nstyled markup to resolve each issue one at a time. This is expected to be populated by invocations of\nstyerr!.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.isnextchar","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.isnextchar","category":"function","text":"isnextchar(state::State, char::Char) -> Bool\nisnextchar(state::State, chars::NTuple{N, Char}) -> Bool\n\nCheck if state has a next character, and if so whether it is char or one of chars.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.ismacro","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.ismacro","category":"function","text":"ismacro(state::State) -> Bool\n\nCheck whether state is indicated to come from a macro invocation,\naccording to whether state.mod is set or not.\n\nWhile this function is rather trivial, it clarifies the intent when used instead\nof just checking state.mod.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.styerr!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.styerr!","category":"function","text":"styerr!(state::State, message::AbstractString, position::Union{Nothing, Int}=nothing, hint::String=\"around here\")\n\nRegister an error in state based on erroneous content at or around position\n(if known, and with a certain hint as to the location), with the nature of the\nerror given by message.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.hygienic_eval","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.hygienic_eval","category":"function","text":"hygienic_eval(state::State, expr)\n\nEvaluate expr within the scope of state's module.\nThis replicates part of the behind-the-scenes behaviour of macro expansion, we\njust need to manually invoke it due to the particularities around dealing with\ncode from a foreign module that we parse ourselves.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.addpart!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.addpart!","category":"function","text":"addpart!(state::State, stop::Int)\n\nCreate a new part from state.point to stop, applying all pending styles.\n\nThis consumes all the content between state.point and  stop, and shifts\nstate.point to be the index after stop.\n\n\n\n\n\naddpart!(state::State, start::Int, expr, stop::Int)\n\nCreate a new part based on (the eventual evaluation of) expr, running from\nstart to stop, taking the currently active styles into account.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.escaped!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.escaped!","category":"function","text":"escaped!(state::State, i::Int, char::Char)\n\nParse the escaped character char, at index i, into state\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.interpolated!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.interpolated!","category":"function","text":"interpolated!(state::State, i::Int, _)\n\nInterpolate the expression starting at i, and add it as a part to state.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.readexpr!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.readexpr!","category":"function","text":"readexpr!(state::State, pos::Int = first(popfirst!(state.s)) + 1)\n\nRead the expression starting at pos in state.content, and consume state.s\nas appropriate to align the iterator to the end of the expression.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.skipwhitespace!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.skipwhitespace!","category":"function","text":"skipwhitespace!(state::State)\n\nSkip forwards all space, tab, and newline characters in state.s\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.read_while!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.read_while!","category":"function","text":"read_while!(f::Function, state::Base.Stateful, lastchar::Char)\n\nRead state until f(::Char) is false.\n\nGiven a Stateful that iterates (_, char::Char) pairs, and a predicate\nf(::Char)::Bool, return (str, lastchar), where str::String contains all the\nchar for which f(char) == true, and lastchar the last char element seen,\nor the input lastchar there are no elements of state.\n\nExamples\n\njulia> s = Base.Stateful(pairs(\"abc\"));\n\njulia> read_while!(isnumeric, s, 'w')\n(\"\", 'a')\n\njulia> first(s) # s is mutated\n2 => 'b'\n\njulia> read_while!(isascii, Base.Stateful(pairs(\"123Σω\")), 'k')\n(\"123\", 'Σ')\n\njulia> read_while!(isascii, Base.Stateful(pairs(\"abcde\")), 'α')\n(\"abcde\", 'e')\n\njulia> read_while!(isascii , Base.Stateful(pairs(\"\")), 'k')\n(\"\", 'k')\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.begin_style!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.begin_style!","category":"function","text":"begin_style!(state::State, i::Int, char::Char)\n\nParse the style declaration beginning at i (char) with read_annotation!,\nand register it in the active styles list.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.end_style!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.end_style!","category":"function","text":"end_style!(state::State, i::Int, char::Char)\n\nClose of the most recent active style in state, making it a pending style.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.read_annotation!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.read_annotation!","category":"function","text":"read_annotation!(state::State, i::Int, char::Char, newstyles::Vector) -> Bool\n\nRead the annotations at i (char), and push the style read to newstyles.\n\nThis skips whitespace and checks what the next character in state.s is,\ndetects the form of the annotation, and parses it using the appropriate\nspecialised function like so:\n\n:, end of annotation, do nothing\n(, inline face declaration, use read_inlineface!\notherwise, use read_face_or_keyval!\n\nAfter parsing the annotation, returns a boolean value signifying whether there\nis an immediately subsequent annotation to be read.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.read_inlineface!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.read_inlineface!","category":"function","text":"read_inlineface!(state::State, i::Int, char::Char, newstyles)\n\nRead an inline face declaration from state, at position i (char), and add\nit to newstyles.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.read_face_or_keyval!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.read_face_or_keyval!","category":"function","text":"read_face_or_keyval!(state::State, i::Int, char::Char, newstyles)\n\nRead an inline face or key-value pair from state at position i (char), and\nadd it to newstyles.\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.run_state_machine!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.run_state_machine!","category":"function","text":"run_state_machine!(state::State)\n\nIterate through state.s, applying the parsing rules for the top-level of\nsyntax and calling the relevant specialised functions.\n\nUpon completion, state.s should be fully consumed and state.parts fully\npopulated (along with state.errors).\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.annotatedstring_optimize!","page":"Internals","location":"internals/#StyledStrings.StyledMarkup.annotatedstring_optimize!","category":"function","text":"annotatedstring_optimize!(str::AnnotatedString)\n\nMerge contiguous identical annotations in str.\n\n\n\n\n\n"},{"title":"StyledStrings","page":"StyledStrings","location":"#stdlib-styledstrings","category":"section","text":"note: Note\nThe API for StyledStrings and AnnotatedStrings is considered experimental and is subject to change between\nJulia versions."},{"title":"Styling","page":"StyledStrings","location":"#stdlib-styledstrings-styling","category":"section","text":"When working with strings, formatting and styling often appear as a secondary\nconcern.\n\nFor instance, when printing to a terminal you might want to sprinkle [ANSI\nescape\nsequences](https://en.wikipedia.org/wiki/ANSIescapecode#SGR(SelectGraphicRendition)parameters)\nin the output, when outputting HTML styling constructs (<span style=\"...\">,\netc.) serve a similar purpose, and so on. It is possible to simply insert the\nraw styling constructs into the string next to the content itself, but it\nquickly becomes apparent that this is not well suited for anything but the most\nbasic use cases. Not all terminals support the same ANSI codes, the styling\nconstructs need to be painstakingly removed when calculating the width of\nalready-styled content, and that's before you even get into handling multiple\noutput formats.\n\nInstead of leaving this headache to be widely experienced downstream, it is\ntackled head-on by the introduction of a special string type\n(AnnotatedString). This string type wraps any other\nAbstractString type and allows for formatting information to be applied to regions (e.g.\ncharacters 1 through to 7 are bold and red).\n\nRegions of a string are styled by applying Faces\n(think \"typeface\") to them — a structure that holds styling information. As a\nconvenience, faces in the global faces dictionary (e.g. shadow) can just be\nnamed instead of giving the Face directly.\n\nAlong with these capabilities, we also provide a convenient way for constructing\nAnnotatedStrings, detailed in [Styled String\nLiterals](@ref stdlib-styledstring-literals).\n\nusing StyledStrings\nstyled\"{yellow:hello} {blue:there}\""},{"title":"Annotated Strings","page":"StyledStrings","location":"#man-annotated-strings","category":"section","text":"It is sometimes useful to be able to hold metadata relating to regions of a\nstring. A AnnotatedString wraps another string and\nallows for regions of it to be annotated with labelled values (:label => value).\nAll generic string operations are applied to the underlying string. However,\nwhen possible, styling information is preserved. This means you can manipulate a\nAnnotatedString —taking substrings, padding them,\nconcatenating them with other strings— and the metadata annotations will \"come\nalong for the ride\".\n\nThis string type is fundamental to the [StyledStrings stdlib](@ref\nstdlib-styledstrings), which uses :face-labelled annotations to hold styling\ninformation.\n\nWhen concatenating a AnnotatedString, take care to use\nannotatedstring instead of string if you want\nto keep the string annotations.\n\njulia> str = AnnotatedString(\"hello there\", [(1:5, :word, :greeting), (7:11, :label, 1)])\n\"hello there\"\n\njulia> length(str)\n11\n\njulia> lpad(str, 14)\n\"   hello there\"\n\njulia> typeof(lpad(str, 7))\nAnnotatedString{String}\n\njulia> str2 = AnnotatedString(\" julia\", [(2:6, :face, :magenta)])\n\" julia\"\n\njulia> annotatedstring(str, str2)\n\"hello there julia\"\n\njulia> str * str2 == annotatedstring(str, str2) # *-concatenation works\ntrue\n\nThe annotations of a AnnotatedString can be accessed\nand modified via the annotations and\nannotate! functions."},{"title":"Styling via AnnotatedStrings","page":"StyledStrings","location":"#Styling-via-[AnnotatedString](@ref-Base.AnnotatedString)s","category":"section","text":""},{"title":"Faces","page":"StyledStrings","location":"#stdlib-styledstrings-faces","category":"section","text":""},{"title":"The Face type","page":"StyledStrings","location":"#The-Face-type","category":"section","text":"A Face specifies details of a typeface that text can be set in. It\ncovers a set of basic attributes that generalize well across different formats,\nnamely:\n\nfont\nheight\nweight\nslant\nforeground\nbackground\nunderline\nstrikethrough\ninverse\ninherit\n\nFor details on the particular forms these attributes take, see the\nFace docstring, but of particular interest is inherit as it allows\nyou to inherit attributes from other Faces."},{"title":"The global faces dictionary","page":"StyledStrings","location":"#The-global-faces-dictionary","category":"section","text":"To make referring to particular styles more convenient, there is a global\nDict{Symbol, Face} that allows for Faces to be\nreferred to simply by name. Packages can add faces to this dictionary via the\naddface! function, and the loaded faces can be\neasily customized.\n\nwarning: Appropriate face naming\nAny package registering new faces should ensure that they are prefixed\nby the package name, i.e. follow the format mypackage_myface.\nThis is important for predictability, and to prevent name clashes.Furthermore, packages should take care to use (and introduce) semantic\nfaces (like code) over direct colours and styles (like cyan). This is helpful\nin a number of ways, from making the intent in usage more obvious, aiding\ncomposability, and making user customisation more intuitive.\n\nThere are two set of exemptions to the package-prefix rule:\n\nthe set of basic faces that are part of the default value of the faces dictionary\nfaces introduced by Julia's own standard library, namely JuliaSyntaxHighlighting"},{"title":"Basic faces","page":"StyledStrings","location":"#stdlib-styledstrings-basic-faces","category":"section","text":"Basic faces are intended to represent a general idea that is widely applicable.\n\nFor setting some text with a certain attribute, we have the bold, light,\nitalic, underline, strikethrough, and inverse faces.\n\nThere are also named faces for the 16 terminal colors: black, red, green,\nyellow, blue, magenta, cyan, white, bright_black/grey/gray,\nbright_red, bright_green, bright_blue, bright_magenta, bright_cyan,\nand bright_white.\n\nFor shadowed text (i.e. dim but there) there is the shadow face. To indicate a\nselected region, there is the region face. Similarly for emphasis and\nhighlighting the emphasis and highlight faces are defined. There is also\ncode for code-like text.\n\nFor visually indicating the severity of messages, the error, warning,\nsuccess, info, note, and tip faces are defined."},{"title":"Customisation of faces (Faces.toml)","page":"StyledStrings","location":"#stdlib-styledstrings-face-toml","category":"section","text":"It is good for the name faces in the global face dictionary to be customizable.\nTheming and aesthetics are nice, and it is important for accessibility reasons\ntoo. A TOML file can be parsed into a list of Face specifications that\nare merged with the pre-existing entry in the face dictionary.\n\nA Face is represented in TOML like so:\n\n[facename]\nattribute = \"value\"\n...\n\n[package.facename]\nattribute = \"value\"\n\nFor example, if the shadow face is too hard to read it can be made brighter\nlike so:\n\n[shadow]\nforeground = \"white\"\n\nOn initialization, the config/faces.toml file under the first Julia depot (usually ~/.julia) is loaded."},{"title":"Applying faces to a AnnotatedString","page":"StyledStrings","location":"#Applying-faces-to-a-AnnotatedString","category":"section","text":"By convention, the :face attributes of a [AnnotatedString](@ref\nBase.AnnotatedString) hold information on the Faces\nthat currently apply. This can be given in multiple forms, as a single Symbol\nnaming a Faces in the global face dictionary, a\nFace itself, or a vector of either.\n\nThe show(::IO, ::MIME\"text/plain\", ::AnnotatedString) and show(::IO, ::MIME\"text/html\", ::AnnotatedString) methods both look at the :face attributes\nand merge them all together when determining the overall styling.\n\nWe can supply :face attributes to a AnnotatedString during construction, add\nthem to the properties list afterwards, or use the convenient [Styled String\nliterals](@ref stdlib-styledstring-literals).\n\nstr1 = AnnotatedString(\"blue text\", [(1:9, :face, :blue)])\nstr2 = styled\"{blue:blue text}\"\nstr1 == str2\nsprint(print, str1, context = :color => true)\nsprint(show, MIME(\"text/html\"), str1, context = :color => true)"},{"title":"Styled String Literals","page":"StyledStrings","location":"#stdlib-styledstring-literals","category":"section","text":"To ease construction of AnnotatedStrings with Faces applied,\nthe styled\"...\" styled string literal allows for the content and\nattributes to be easily expressed together via a custom grammar.\n\nWithin a styled\"...\" literal, curly braces are considered\nspecial characters and must be escaped in normal usage (\\{, \\}). This allows\nthem to be used to express annotations with (nestable) {annotations...:text}\nconstructs.\n\nThe annotations... component is a comma-separated list of three types of annotations.\n\nFace names\nInline Face expressions (key=val,...)\nkey=value pairs\n\nInterpolation is possible everywhere except for inline face keys.\n\nFor more information on the grammar, see the extended help of the\nstyled\"...\" docstring.\n\nAs an example, we can demonstrate the list of built-in faces mentioned above like so:\n\njulia> println(styled\"\nThe basic font-style attributes are {bold:bold}, {light:light}, {italic:italic},\n{underline:underline}, and {strikethrough:strikethrough}.\n\nIn terms of color, we have named faces for the 16 standard terminal colors:\n {black:■} {red:■} {green:■} {yellow:■} {blue:■} {magenta:■} {cyan:■} {white:■}\n {bright_black:■} {bright_red:■} {bright_green:■} {bright_yellow:■} {bright_blue:■} {bright_magenta:■} {bright_cyan:■} {bright_white:■}\n\nSince {code:bright_black} is effectively grey, we define two aliases for it:\n{code:grey} and {code:gray} to allow for regional spelling differences.\n\nTo flip the foreground and background colors of some text, you can use the\n{code:inverse} face, for example: {magenta:some {inverse:inverse} text}.\n\nThe intent-based basic faces are {shadow:shadow} (for dim but visible text),\n{region:region} for selections, {emphasis:emphasis}, and {highlight:highlight}.\nAs above, {code:code} is used for code-like text.\n\nLastly, we have the 'message severity' faces: {error:error}, {warning:warning},\n{success:success}, {info:info}, {note:note}, and {tip:tip}.\n\nRemember that all these faces (and any user or package-defined ones) can\narbitrarily nest and overlap, {region,tip:like {bold,italic:so}}.\")\n\nDocumenter doesn't properly represent all the styling above, so I've converted it manually to HTML and LaTeX.\n\n<pre>\n The basic font-style attributes are <span style=\"font-weight: 700;\">bold</span>, <span style=\"font-weight: 300;\">light</span>, <span style=\"font-style: italic;\">italic</span>,\n <span style=\"text-decoration: underline;\">underline</span>, and <span style=\"text-decoration: line-through\">strikethrough</span>.\n\n In terms of color, we have named faces for the 16 standard terminal colors:\n  <span style=\"color: #1c1a23;\">■</span> <span style=\"color: #a51c2c;\">■</span> <span style=\"color: #25a268;\">■</span> <span style=\"color: #e5a509;\">■</span> <span style=\"color: #195eb3;\">■</span> <span style=\"color: #803d9b;\">■</span> <span style=\"color: #0097a7;\">■</span> <span style=\"color: #dddcd9;\">■</span>\n  <span style=\"color: #76757a;\">■</span> <span style=\"color: #ed333b;\">■</span> <span style=\"color: #33d079;\">■</span> <span style=\"color: #f6d22c;\">■</span> <span style=\"color: #3583e4;\">■</span> <span style=\"color: #bf60ca;\">■</span> <span style=\"color: #26c6da;\">■</span> <span style=\"color: #f6f5f4;\">■</span>\n\n Since <span style=\"color: #0097a7;\">bright_black</span> is effectively grey, we define two aliases for it:\n <span style=\"color: #0097a7;\">grey</span> and <span style=\"color: #0097a7;\">gray</span> to allow for regional spelling differences.\n\n To flip the foreground and background colors of some text, you can use the\n <span style=\"color: #0097a7;\">inverse</span> face, for example: <span style=\"color: #803d9b;\">some </span><span style=\"background-color: #803d9b;\">inverse</span><span style=\"color: #803d9b;\"> text</span>.\n\n The intent-based basic faces are <span style=\"color: #76757a;\">shadow</span> (for dim but visible text),\n <span style=\"background-color: #3a3a3a;\">region</span> for selections, <span style=\"color: #195eb3;\">emphasis</span>, and <span style=\"background-color: #195eb3;\">highlight</span>.\n As above, <span style=\"color: #0097a7;\">code</span> is used for code-like text.\n\n Lastly, we have the 'message severity' faces: <span style=\"color: #ed333b;\">error</span>, <span style=\"color: #e5a509;\">warning</span>,\n <span style=\"color: #25a268;\">success</span>, <span style=\"color: #26c6da;\">info</span>, <span style=\"color: #76757a;\">note</span>, and <span style=\"color: #33d079;\">tip</span>.\n\n Remember that all these faces (and any user or package-defined ones) can\n arbitrarily nest and overlap, <span style=\"color: #33d079;background-color: #3a3a3a;\">like <span style=\"font-weight: 700;font-style: italic;\">so</span></span>.</pre>\n\n\\begingroup\n\\ttfamily\n\\setlength{\\parindent}{0pt}\n\\setlength{\\parskip}{\\baselineskip}\n\nThe basic font-style attributes are {\\fontseries{b}\\selectfont bold}, {\\fontseries{l}\\selectfont light}, {\\fontshape{it}\\selectfont italic},\\\\\n\\underline{underline}, and {strikethrough}.\n\nIn terms of color, we have named faces for the 16 standard terminal colors:\\\\\n{\\color[HTML]{1c1a23}\\(\\blacksquare\\)} {\\color[HTML]{a51c2c}\\(\\blacksquare\\)} {\\color[HTML]{25a268}\\(\\blacksquare\\)}\n{\\color[HTML]{e5a509}\\(\\blacksquare\\)} {\\color[HTML]{195eb3}\\(\\blacksquare\\)} {\\color[HTML]{803d9b}\\(\\blacksquare\\)}\n{\\color[HTML]{0097a7}\\(\\blacksquare\\)} {\\color[HTML]{dddcd9}\\(\\blacksquare\\)} \\\\\n{\\color[HTML]{76757a}\\(\\blacksquare\\)} {\\color[HTML]{ed333b}\\(\\blacksquare\\)} {\\color[HTML]{33d079}\\(\\blacksquare\\)} {\\color[HTML]{f6d22c}\\(\\blacksquare\\)} {\\color[HTML]{3583e4}\\(\\blacksquare\\)} {\\color[HTML]{bf60ca}\\(\\blacksquare\\)} {\\color[HTML]{26c6da}\\(\\blacksquare\\)} {\\color[HTML]{f6f5f4}\\(\\blacksquare\\)}\n\nSince {\\color[HTML]{0097a7}bright\\_black} is effectively grey, we define two aliases for it:\\\\\n{\\color[HTML]{0097a7}grey} and {\\color[HTML]{0097a7}gray} to allow for regional spelling differences.\n\nTo flip the foreground and background colors of some text, you can use the\\\\\n{\\color[HTML]{0097a7}inverse} face, for example: {\\color[HTML]{803d9b}some \\colorbox[HTML]{803d9b}{\\color[HTML]{000000}inverse} text}.\n\nThe intent-based basic faces are {\\color[HTML]{76757a}shadow} (for dim but visible text),\\\\\n\\colorbox[HTML]{3a3a3a}{region} for selections, {\\color[HTML]{195eb3}emphasis}, and \\colorbox[HTML]{195eb3}{highlight}.\\\\\nAs above, {\\color[HTML]{0097a7}code} is used for code-like text.\n\nLastly, we have the 'message severity' faces: {\\color[HTML]{ed333b}error}, {\\color[HTML]{e5a509}warning},\\\\\n{\\color[HTML]{25a268}success}, {\\color[HTML]{26c6da}info}, {\\color[HTML]{76757a}note}, and {\\color[HTML]{33d079}tip}.\n\nRemember that all these faces (and any user or package-defined ones) can\\\\\narbitrarily nest and overlap, \\colorbox[HTML]{3a3a3a}{\\color[HTML]{33d079}like\n  {\\fontseries{b}\\fontshape{it}\\selectfont so}}.\n\\endgroup"},{"title":"API reference","page":"StyledStrings","location":"#stdlib-styledstrings-api","category":"section","text":""},{"title":"Styling and Faces","page":"StyledStrings","location":"#Styling-and-Faces","category":"section","text":""},{"title":"StyledStrings.StyledMarkup.@styled_str","page":"StyledStrings","location":"#StyledStrings.StyledMarkup.@styled_str","category":"macro","text":"@styled_str -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures\napply the formatting to <content>, according to the list of comma-separated\nspecifications <specs>. Each spec can either take the form of a face name,\nan inline face specification, or a key=value pair. The value must be wrapped\nby {...} should it contain any of the characters ,=:{}.\n\nString interpolation with $ functions in the same way as regular strings,\nexcept quotes need to be escaped. Faces, keys, and values can also be\ninterpolated with $.\n\nExample\n\nstyled\"The {bold:{italic:quick} {(foreground=#cd853f):brown} fox} jumped over the {link={https://en.wikipedia.org/wiki/Laziness}:lazy} dog\"\n\nExtended help\n\nThis macro can be described by the following EBNF grammar:\n\nstyledstring = { styled | interpolated | escaped | plain } ;\n\nspecialchar = '{' | '}' | '$' | '\\\"' ;\nanychar = [\\u0-\\u1fffff] ;\nplain = { anychar - specialchar } ;\nescaped = '\\\\', specialchar ;\n\ninterpolated = '$', ? expr ? | '$(', ? expr ?, ')' ;\n\nstyled = '{', ws, annotations, ':', content, '}' ;\ncontent = { interpolated | plain | escaped | styled } ;\nannotations = annotation | annotations, ws, ',', ws, annotation ;\nannotation = face | inlineface | keyvalue ;\nws = { ' ' | '\\t' | '\\n' } ; (* whitespace *)\n\nface = facename | interpolated ;\nfacename = [A-Za-z0-9_]+ ;\n\ninlineface = '(', ws, [ faceprop ], { ws, ',', faceprop }, ws, ')' ;\nfaceprop = [a-z]+, ws, '=', ws, ( [^,)]+ | interpolated) ;\n\nkeyvalue = key, ws, '=', ws, value ;\nkey = ( [^\\0${}=,:], [^\\0=,:]* ) | interpolated ;\nvalue = simplevalue | curlybraced | interpolated ;\ncurlybraced = '{' { escaped | plain } '}' ;\nsimplevalue = [^${},:], [^,:]* ;\n\nAn extra stipulation not encoded in the above grammar is that plain should be\na valid input to unescape_string, with specialchar kept.\n\nThe above grammar for inlineface is simplified, as the actual implementation\nis a bit more sophisticated. The full behaviour is given below.\n\nfaceprop = ( 'face', ws, '=', ws, ( ? string ? | interpolated ) ) |\n           ( 'height', ws, '=', ws, ( ? number ? | interpolated ) ) |\n           ( 'weight', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( 'slant', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( ( 'foreground' | 'fg' | 'background' | 'bg' ),\n               ws, '=', ws, ( simplecolor | interpolated ) ) |\n           ( 'underline', ws, '=', ws, ( underline | interpolated ) ) |\n           ( 'strikethrough', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inverse', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inherit', ws, '=', ws, ( inherit | interpolated ) ) ;\n\nnothing = 'nothing' ;\nbool = 'true' | 'false' ;\nsymbol = [^ ,)]+ ;\nhexcolor = ('#' | '0x'), [0-9a-f]{6} ;\nsimplecolor = hexcolor | symbol | nothing ;\n\nunderline = nothing | bool | simplecolor | underlinestyled;\nunderlinestyled = '(', ws, ('' | nothing | simplecolor | interpolated), ws,\n                  ',', ws, ( symbol | interpolated ), ws ')' ;\n\ninherit = ( '[', inheritval, { ',', inheritval }, ']' ) | inheritval;\ninheritval = ws, ':'?, symbol ;\n\n\n\n\n\n"},{"title":"StyledStrings.StyledMarkup.styled","page":"StyledStrings","location":"#StyledStrings.StyledMarkup.styled","category":"function","text":"styled(content::AbstractString) -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures\napply the formatting to <content>, according to the list of comma-separated\nspecifications <specs>. Each spec can either take the form of a face name,\nan inline face specification, or a key=value pair. The value must be wrapped\nby {...} should it contain any of the characters ,=:{}.\n\nThis is a functional equivalent of the @styled_str macro, just without\ninterpolation capabilities.\n\n\n\n\n\n"},{"title":"StyledStrings.Face","page":"StyledStrings","location":"#StyledStrings.Face","category":"type","text":"A Face is a collection of graphical attributes for displaying text.\nFaces control how text is displayed in the terminal, and possibly other\nplaces too.\n\nMost of the time, a Face will be stored in the global faces dicts as a\nunique association with a face name Symbol, and will be most often referred to\nby this name instead of the Face object itself.\n\nAttributes\n\nAll attributes can be set via the keyword constructor, and default to nothing.\n\nheight (an Int or Float64): The height in either deci-pt (when an Int),\nor as a factor of the base size (when a Float64).\nweight (a Symbol): One of the symbols (from faintest to densest)\n:thin, :extralight, :light, :semilight, :normal,\n:medium, :semibold, :bold, :extrabold, or :black.\nIn terminals any weight greater than :normal is displayed as bold,\nand in terminals that support variable-brightness text, any weight\nless than :normal is displayed as faint.\nslant (a Symbol): One of the symbols :italic, :oblique, or :normal.\nforeground (a SimpleColor): The text foreground color.\nbackground (a SimpleColor): The text background color.\nunderline, the text underline, which takes one of the following forms:\na Bool: Whether the text should be underlined or not.\n\na SimpleColor: The text should be underlined with this color.\n\na Tuple{Nothing, Symbol}: The text should be underlined using the style\nset by the Symbol, one of :straight, :double, :curly, :dotted,\nor :dashed.\n\na Tuple{SimpleColor, Symbol}: The text should be underlined in the specified\nSimpleColor, and using the style specified by the Symbol, as before.\nstrikethrough (a Bool): Whether the text should be struck through.\ninverse (a Bool): Whether the foreground and background colors should be\ninverted.\ninherit (a Vector{Symbol}): Names of faces to inherit from,\nwith earlier faces taking priority. All faces inherit from the :default face.\n\n\n\n\n\n"},{"title":"StyledStrings.addface!","page":"StyledStrings","location":"#StyledStrings.addface!","category":"function","text":"addface!(name::Symbol => default::Face, theme::Symbol = :base)\n\nCreate a new face by the name name. So long as no face already exists by this\nname, default is added to both FACES.themes[theme] and (a copy of) to\nFACES.current, with the current value returned.\n\nThe theme should be either :base, :light, or :dark.\n\nShould the face name already exist, nothing is returned.\n\nExamples\n\njulia> addface!(:mypkg_myface => Face(slant=:italic, underline=true))\nFace (sample)\n         slant: italic\n     underline: true\n\n\n\n\n\n"},{"title":"StyledStrings.withfaces","page":"StyledStrings","location":"#StyledStrings.withfaces","category":"function","text":"withfaces(f, kv::Pair...)\nwithfaces(f, kvpair_itr)\n\nExecute f with FACES.current temporarily modified by zero or more :name => val arguments kv, or kvpair_itr which produces kv-form values.\n\nwithfaces is generally used via the withfaces(kv...) do ... end syntax. A\nvalue of nothing can be used to temporarily unset a face (if it has been\nset). When withfaces returns, the original FACES.current has been\nrestored.\n\nExamples\n\njulia> withfaces(:yellow => Face(foreground=:red), :green => :blue) do\n           println(styled\"{yellow:red} and {green:blue} mixed make {magenta:purple}\")\n       end\nred and blue mixed make purple\n\n\n\n\n\n"},{"title":"StyledStrings.SimpleColor","page":"StyledStrings","location":"#StyledStrings.SimpleColor","category":"type","text":"struct SimpleColor\n\nA basic representation of a color, intended for string styling purposes.\nIt can either contain a named color (like :red), or an RGBTuple which\nis a NamedTuple specifying an r, g, b color with a bit-depth of 8.\n\nConstructors\n\nSimpleColor(name::Symbol)  # e.g. :red\nSimpleColor(rgb::RGBTuple) # e.g. (r=1, b=2, g=3)\nSimpleColor(r::Integer, b::Integer, b::Integer)\nSimpleColor(rgb::UInt32)   # e.g. 0x123456\n\nAlso see tryparse(SimpleColor, rgb::String).\n\n\n\n\n\n"},{"title":"Base.parse","page":"StyledStrings","location":"#Base.parse-Tuple{Type{StyledStrings.SimpleColor}, String}","category":"method","text":"parse(::Type{SimpleColor}, rgb::String)\n\nAn analogue of tryparse(SimpleColor, rgb::String) (which see),\nthat raises an error instead of returning nothing.\n\n\n\n\n\n"},{"title":"Base.tryparse","page":"StyledStrings","location":"#Base.tryparse-Tuple{Type{StyledStrings.SimpleColor}, String}","category":"method","text":"tryparse(::Type{SimpleColor}, rgb::String)\n\nAttempt to parse rgb as a SimpleColor. If rgb starts with\n# and has a length of 7, it is converted into a RGBTuple-backed SimpleColor.\nIf rgb starts with a-z, rgb is interpreted as a color name\nand converted to a Symbol-backed SimpleColor.\n\nOtherwise, nothing is returned.\n\nExamples\n\njulia> tryparse(SimpleColor, \"blue\")\nSimpleColor(blue)\n\njulia> tryparse(SimpleColor, \"#9558b2\")\nSimpleColor(#9558b2)\n\njulia> tryparse(SimpleColor, \"#nocolor\")\n\n\n\n\n\n"},{"title":"Base.merge","page":"StyledStrings","location":"#Base.merge-Tuple{StyledStrings.Face, StyledStrings.Face}","category":"method","text":"merge(initial::StyledStrings.Face, others::StyledStrings.Face...)\n\nMerge the properties of the initial face and others, with later faces taking priority.\n\nThis is used to combine the styles of multiple faces, and to resolve inheritance.\n\n\n\n\n\n"},{"title":"StyledStrings.blend","page":"StyledStrings","location":"#StyledStrings.blend","category":"function","text":"blend(a::Union{Symbol, SimpleColor}, [b::Union{Symbol, SimpleColor} => α::Real]...)\n\nBlend colors a and b in Oklab space, with mix ratio α (0–1).\n\nThe colors a and b can either be SimpleColors, or Symbols naming a face\nor base color. The mix ratio α combines (1 - α) of a with α of b.\n\nMultiple colors can be blended at once by providing multiple b => α pairs.\n\nExamples\n\njulia> blend(SimpleColor(0xff0000), SimpleColor(0x0000ff), 0.5)\nSimpleColor(■ #8b54a1)\n\njulia> blend(:red, :yellow, 0.7)\nSimpleColor(■ #d47f24)\n\njulia> blend(:green, SimpleColor(0xffffff), 0.3)\nSimpleColor(■ #74be93)\n\n\n\n\n\n"},{"title":"StyledStrings.recolor","page":"StyledStrings","location":"#StyledStrings.recolor","category":"function","text":"recolor(f::Function)\n\nRegister a hook function f to be called whenever the colors change.\n\nUsually hooks will be called once after terminal colors have been\ndetermined. These hooks enable dynamic retheming, but are specifically not run when faces\nare changed. They sit in between the default faces and modifications layered on\ntop with loadface! and user customisations.\n\n\n\n\n\n"}]
}
