var documenterSearchIndex = {"docs":
[{"location":"examples/#Usage-Examples","page":"Example Usage","title":"Usage Examples","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"info: Visual inconsistencies\nThere are some examples on this page that don't quite look as they should, see Documenter.jl#2488 for more information and potential improvements to this situation.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"With flexibility and composability as major considerations in the design of StyledStrings, it is easy to describe the capabilities of this system while failing to actually convey what it can accomplish. With this in mind, examples can be particularly useful to show how it can be used.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"A styled string can be constructed manually, but the styled\"...\" literal is almost always a nicer option. We can see what a manual construction would involve by extracting the string and annotation parts of a AnnotatedString.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"using StyledStrings\nstr = styled\"{yellow:hello} {blue:there}\"\n(String(str), Base.annotations(str))","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"# Due to a bug in Documenter.jl we've run into issues with printing\n# with color. This should always happen here, so we can try a hacky\n# workaround for now.\nBase.get(::IOContext, s::Symbol, d::Bool) = s === :color || d","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Most of the examples here will show AnnotatedString in a terminal/REPL context, however they can be trivially adapted to produce HTML with show(::IO, ::MIME\"text/plain\", ::AnnotatedString), and other packages wanting do deal with styled content in other contexts will likely find integration with StyledStrings worthwhile.","category":"page"},{"location":"examples/#Basic-face-application-and-colouring","page":"Example Usage","title":"Basic face application and colouring","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"As an end-user or a package-author, adding color is one of if not the most frequent application of styling. The default set of colors has the eight ANSI colors, and if we're to be brutally honest, black/white are just shades, leaving us with:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"styled\"{red:■} {green:■} {yellow:■} {blue:■} {magenta:■} {cyan:■}\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"along with \"bright\"  variants","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"styled\"{bright_red:■} {bright_green:■} {bright_yellow:■} \\\n       {bright_blue:■} {bright_magenta:■} {bright_cyan:■}\"","category":"page"},{"location":"examples/#Adding-new-faces","page":"Example Usage","title":"Adding new faces","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"This seems somewhat limited, because it is. This is only the default set of colors though. It is important to note that the way the color red is implemented is by having it name a Face(foreground=:red) value. The ANSI printer knows to handle the ANSI named colors specially, but you can create more \"named colors\" simply by adding new faces.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"StyledStrings.addface!(:orange => StyledStrings.Face(foreground = 0xFF7700))\nstyled\"{orange:this is orange text}\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"warning: Appropriate face naming\nThe face name orange is used here as an example, but this would be inappropriate for a package to introduce as it's missing the packagename_ prefix. This is important for predictability, and to prevent name clashes.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"The fact that named colors are implemented this way also allows for other nice conveniences. For example, if you wanted a more subtle version of the warning styling, you could print text with the underline color set to the warning foreground color.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"styled\"{(underline=warning):this is some minor/slight warning text}\"\nstyled\"A very major {(fg=error,bg=warning),bold:warning!}\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"tip: Focus on semantics, and let style follow\nNote that when using faces, it is generally recommended to focus on the semantic intent, not the specific styling (cyan, bold, etc.), introducing new faces when there is no pre-existing semantically appropriate face.","category":"page"},{"location":"examples/#Inline-face-attributes","page":"Example Usage","title":"Inline face attributes","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Should you want to use a particular color just once, the foreground/fg and background/bg inline face attributes can be set to hex codes.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"styled\"{(fg=#4063d8):ju}{(fg=#389826):l}{(fg=#cb3c33):i}{(fg=#9558b2):a}\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"This works just as well with named colours.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"styled\"Since {orange:orange} is a face with a foreground, \\\n       you can use it as a {(fg=orange):foreground color}.\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"All the other Face attributes can be set similarly.","category":"page"},{"location":"examples/#Considerations-when-creating-and-reusing-faces","page":"Example Usage","title":"Considerations when creating and reusing faces","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"It is recommended that package authors create faces with a focus on the semantic meaning they wish to impart, and then consider what styling suits. For example, say that a hypothetical package foobar wants to mark something as important. Creating a named face allows for it to be re-used across the codebase and allows the styling everywhere its used to be updated by only changing the line declaring it. foobar_important would be an appropriate name for such a face.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"StyledStrings.addface!(:foobar_important => StyledStrings.Face(weight = :bold, inherit = :emphasis))\nstyled\"this is some {foobar_important:rather important} content\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Other packages that interact with foobar can also re-use the foobar_important face for consistent styling. This is possible even for packages that don't have foobar as a direct dependency, as faces that don't exist are just ignored. Consider this styled content as an example:","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"styled\"{info,foobar_important,baz_important:some text}\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"The styling of \"some text\" will be based only on info if neither foobar_important or baz_important are defined. Since foobar_important is defined, after applying the attributes of info, the attributes of foobar_important are applied to \"some text\" overwriting any attributes set by info. Should bar_important be defined in the future, any attributes it sets will override foobar_important and info. Put more simply, the last face mentioned \"wins\".","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"note: Note\nThe silent ignoring of undefined faces is important in making it so that it's known if a styled\"...\" string will cause errors when printed is known at compile-time instead of runtime.","category":"page"},{"location":"examples/#User-customisation-of-faces","page":"Example Usage","title":"User-customisation of faces","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Naming faces also allows for convenient customisation. Once foobar_important is defined, a user can change how it is styled in their faces.toml.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"[foobar.important]\nitalic = true","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"note: Accessibility\nUser-customisation is particularly important when using color, as it allows people with color-blindness or other neuro-ophthalmological abnormalities to make text easier to read/distinguish.","category":"page"},{"location":"examples/#Application-customisation-of-faces","page":"Example Usage","title":"Application-customisation of faces","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Named faces can also be customised on-the-fly in certain printing contexts created by withfaces.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"StyledStrings.withfaces(:foobar_important => :tip) do\n    println(styled\"Sometimes you might want {foobar_important:some text} to look different\")\nend\nStyledStrings.withfaces(:log_info => [:magenta, :italic]) do\n    @info \"Hello there\"\nend","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"This feature can be used to for example change the default colors to follow a certain color theme when generating HTML output.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"StyledStrings.withfaces(:green => StyledStrings.Face(foreground = 0xb7ba25),\n                        :yellow => StyledStrings.Face(foreground = 0xfabc2e),\n                        :magenta => StyledStrings.Face(foreground = 0xd2859a)) do\n    str = styled\"Sometimes you might want {green:different} {yellow:shades} of {magenta:colors}.\"\n    println(str, \"\\n\")\n    show(stdout, MIME(\"text/html\"), str)\nend","category":"page"},{"location":"examples/#Composing-and-interpolating-styled-content","page":"Example Usage","title":"Composing and interpolating styled content","text":"","category":"section"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"As you work with more styled content, the ability to compose styled content and styling information is rather useful. Helpfully, StyledStrings allows for interpolation of both content and attributes.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"small_rainbow = (:red, :yellow, :green, :blue, :magenta)\ncolor = join([styled\"{$f:$c}\" for (f, c) in tuple.(small_rainbow, collect(\"color\"))])\nstyled\"It's nice to include $color, and it composes too: {bold,inverse:$color}\"","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"Sometimes it's useful to compose a string incrementally, or interoperate with other IO-based code. For these use-cases, the AnnotatedIOBuffer is very handy, as you can read an AnnotatedString from it.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"aio = Base.AnnotatedIOBuffer()\ntyp = Int\nprint(aio, typ)\nwhile typ != Any # We'll pretend that `supertypes` doesn't exist.\n    typ = supertype(typ)\n    print(aio, styled\" {bright_red:<:} $typ\")\nend\nread(seekstart(aio), Base.AnnotatedString)","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"StyledStrings adds a specialised printstyled method printstyled(::AnnotatedIOBuffer, ...) that means that you can pass an AnnotatedIOBuffer as IO to \"legacy\" code written to use printstyled, and extract all the styling as though it had used styled\"...\" macros.","category":"page"},{"location":"examples/","page":"Example Usage","title":"Example Usage","text":"aio = Base.AnnotatedIOBuffer()\nprintstyled(aio, 'c', color=:red)\nprintstyled(aio, 'o', color=:yellow)\nprintstyled(aio, 'l', color=:green)\nprintstyled(aio, 'o', color=:blue)\nprintstyled(aio, 'r', color=:magenta)\nread(seekstart(aio), Base.AnnotatedString)\nread(seekstart(aio), String)","category":"page"},{"location":"#stdlib-styledstrings","page":"StyledStrings","title":"StyledStrings","text":"","category":"section"},{"location":"#stdlib-styledstrings-styling","page":"StyledStrings","title":"Styling","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"When working with strings, formatting and styling often appear as a secondary concern.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For instance, when printing to a terminal you might want to sprinkle ANSI escape sequences in the output, when outputting HTML styling constructs (<span style=\"...\">, etc.) serve a similar purpose, and so on. It is possible to simply insert the raw styling constructs into the string next to the content itself, but it quickly becomes apparent that this is not well suited for anything but the most basic use cases. Not all terminals support the same ANSI codes, the styling constructs need to be painstakingly removed when calculating the width of already-styled content, and that's before you even get into handling multiple output formats.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Instead of leaving this headache to be widely experienced downstream, it is tackled head-on by the introduction of a special string type (AnnotatedString). This string type wraps any other AbstractString type and allows for formatting information to be applied to regions (e.g. characters 1 through to 7 are bold and red).","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Regions of a string are styled by applying Faces (think \"typeface\") to them — a structure that holds styling information. As a convenience, faces in the global faces dictionary (e.g. shadow) can just be named instead of giving the Face directly.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Along with these capabilities, we also provide a convenient way for constructing AnnotatedStrings, detailed in Styled String Literals.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"using StyledStrings\nstyled\"{yellow:hello} {blue:there}\"","category":"page"},{"location":"#Styling-via-[AnnotatedString](@ref-Base.AnnotatedString)s","page":"StyledStrings","title":"Styling via AnnotatedStrings","text":"","category":"section"},{"location":"#stdlib-styledstrings-faces","page":"StyledStrings","title":"Faces","text":"","category":"section"},{"location":"#The-Face-type","page":"StyledStrings","title":"The Face type","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"A Face specifies details of a typeface that text can be set in. It covers a set of basic attributes that generalize well across different formats, namely:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"font\nheight\nweight\nslant\nforeground\nbackground\nunderline\nstrikethrough\ninverse\ninherit","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For details on the particular forms these attributes take, see the Face docstring, but of particular interest is inherit as it allows you to inherit attributes from other Faces.","category":"page"},{"location":"#The-global-faces-dictionary","page":"StyledStrings","title":"The global faces dictionary","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"To make referring to particular styles more convenient, there is a global Dict{Symbol, Face} that allows for Faces to be referred to simply by name. Packages can add faces to this dictionary via the addface! function, and the loaded faces can be easily customized.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"warning: Appropriate face naming\nAny package registering new faces should ensure that they are prefixed by the package name, i.e. follow the format mypackage_myface. This is important for predictability, and to prevent name clashes.Furthermore, packages should take care to use (and introduce) semantic faces (like code) over direct colours and styles (like cyan). This is helpful in a number of ways, from making the intent in usage more obvious, aiding composability, and making user customisation more intuitive.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"There are two set of exemptions to the package-prefix rule:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"the set of basic faces that are part of the default value of the faces dictionary\nfaces introduced by Julia's own standard library, namely JuliaSyntaxHighlighting","category":"page"},{"location":"#stdlib-styledstrings-basic-faces","page":"StyledStrings","title":"Basic faces","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Basic faces are intended to represent a general idea that is widely applicable.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For setting some text with a certain attribute, we have the bold, light, italic, underline, strikethrough, and inverse faces.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"There are also named faces for the 16 terminal colors: black, red, green, yellow, blue, magenta, cyan, white, bright_black/grey/gray, bright_red, bright_green, bright_blue, bright_magenta, bright_cyan, and bright_white.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For shadowed text (i.e. dim but there) there is the shadow face. To indicate a selected region, there is the region face. Similarly for emphasis and highlighting the emphasis and highlight faces are defined. There is also code for code-like text.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For visually indicating the severity of messages, the error, warning, success, info, note, and tip faces are defined.","category":"page"},{"location":"#stdlib-styledstrings-face-toml","page":"StyledStrings","title":"Customisation of faces (Faces.toml)","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"It is good for the name faces in the global face dictionary to be customizable. Theming and aesthetics are nice, and it is important for accessibility reasons too. A TOML file can be parsed into a list of Face specifications that are merged with the pre-existing entry in the face dictionary.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"A Face is represented in TOML like so:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"[facename]\nattribute = \"value\"\n...\n\n[package.facename]\nattribute = \"value\"","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For example, if the shadow face is too hard to read it can be made brighter like so:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"[shadow]\nforeground = \"white\"","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"On initialization, the config/faces.toml file under the first Julia depot (usually ~/.julia) is loaded.","category":"page"},{"location":"#Applying-faces-to-a-AnnotatedString","page":"StyledStrings","title":"Applying faces to a AnnotatedString","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"By convention, the :face attributes of a AnnotatedString hold information on the Faces that currently apply. This can be given in multiple forms, as a single Symbol naming a Faces in the global face dictionary, a Face itself, or a vector of either.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"The show(::IO, ::MIME\"text/plain\", ::AnnotatedString) and show(::IO, ::MIME\"text/html\", ::AnnotatedString) methods both look at the :face attributes and merge them all together when determining the overall styling.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"We can supply :face attributes to a AnnotatedString during construction, add them to the properties list afterwards, or use the convenient Styled String literals.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"str1 = Base.AnnotatedString(\"blue text\", [(1:9, :face => :blue)])\nstr2 = styled\"{blue:blue text}\"\nstr1 == str2\nsprint(print, str1, context = :color => true)\nsprint(show, MIME(\"text/html\"), str1, context = :color => true)","category":"page"},{"location":"#stdlib-styledstring-literals","page":"StyledStrings","title":"Styled String Literals","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"To ease construction of AnnotatedStrings with Faces applied, the styled\"...\" styled string literal allows for the content and attributes to be easily expressed together via a custom grammar.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Within a styled\"...\" literal, curly braces are considered special characters and must be escaped in normal usage (\\{, \\}). This allows them to be used to express annotations with (nestable) {annotations...:text} constructs.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"The annotations... component is a comma-separated list of three types of annotations.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Face names\nInline Face expressions (key=val,...)\nkey=value pairs","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Interpolation is possible everywhere except for inline face keys.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"For more information on the grammar, see the extended help of the styled\"...\" docstring.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"As an example, we can demonstrate the list of built-in faces mentioned above like so:","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"julia> println(styled\"\nThe basic font-style attributes are {bold:bold}, {light:light}, {italic:italic},\n{underline:underline}, and {strikethrough:strikethrough}.\n\nIn terms of color, we have named faces for the 16 standard terminal colors:\n {black:■} {red:■} {green:■} {yellow:■} {blue:■} {magenta:■} {cyan:■} {white:■}\n {bright_black:■} {bright_red:■} {bright_green:■} {bright_yellow:■} {bright_blue:■} {bright_magenta:■} {bright_cyan:■} {bright_white:■}\n\nSince {code:bright_black} is effectively grey, we define two aliases for it:\n{code:grey} and {code:gray} to allow for regional spelling differences.\n\nTo flip the foreground and background colors of some text, you can use the\n{code:inverse} face, for example: {magenta:some {inverse:inverse} text}.\n\nThe intent-based basic faces are {shadow:shadow} (for dim but visible text),\n{region:region} for selections, {emphasis:emphasis}, and {highlight:highlight}.\nAs above, {code:code} is used for code-like text.\n\nLastly, we have the 'message severity' faces: {error:error}, {warning:warning},\n{success:success}, {info:info}, {note:note}, and {tip:tip}.\n\nRemember that all these faces (and any user or package-defined ones) can\narbitrarily nest and overlap, {region,tip:like {bold,italic:so}}.\")","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"Documenter doesn't properly represent all the styling above, so I've converted it manually to HTML and LaTeX.","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"<pre>\n The basic font-style attributes are <span style=\"font-weight: 700;\">bold</span>, <span style=\"font-weight: 300;\">light</span>, <span style=\"font-style: italic;\">italic</span>,\n <span style=\"text-decoration: underline;\">underline</span>, and <span style=\"text-decoration: line-through\">strikethrough</span>.\n\n In terms of color, we have named faces for the 16 standard terminal colors:\n  <span style=\"color: #1c1a23;\">■</span> <span style=\"color: #a51c2c;\">■</span> <span style=\"color: #25a268;\">■</span> <span style=\"color: #e5a509;\">■</span> <span style=\"color: #195eb3;\">■</span> <span style=\"color: #803d9b;\">■</span> <span style=\"color: #0097a7;\">■</span> <span style=\"color: #dddcd9;\">■</span>\n  <span style=\"color: #76757a;\">■</span> <span style=\"color: #ed333b;\">■</span> <span style=\"color: #33d079;\">■</span> <span style=\"color: #f6d22c;\">■</span> <span style=\"color: #3583e4;\">■</span> <span style=\"color: #bf60ca;\">■</span> <span style=\"color: #26c6da;\">■</span> <span style=\"color: #f6f5f4;\">■</span>\n\n Since <span style=\"color: #0097a7;\">bright_black</span> is effectively grey, we define two aliases for it:\n <span style=\"color: #0097a7;\">grey</span> and <span style=\"color: #0097a7;\">gray</span> to allow for regional spelling differences.\n\n To flip the foreground and background colors of some text, you can use the\n <span style=\"color: #0097a7;\">inverse</span> face, for example: <span style=\"color: #803d9b;\">some </span><span style=\"background-color: #803d9b;\">inverse</span><span style=\"color: #803d9b;\"> text</span>.\n\n The intent-based basic faces are <span style=\"color: #76757a;\">shadow</span> (for dim but visible text),\n <span style=\"background-color: #3a3a3a;\">region</span> for selections, <span style=\"color: #195eb3;\">emphasis</span>, and <span style=\"background-color: #195eb3;\">highlight</span>.\n As above, <span style=\"color: #0097a7;\">code</span> is used for code-like text.\n\n Lastly, we have the 'message severity' faces: <span style=\"color: #ed333b;\">error</span>, <span style=\"color: #e5a509;\">warning</span>,\n <span style=\"color: #25a268;\">success</span>, <span style=\"color: #26c6da;\">info</span>, <span style=\"color: #76757a;\">note</span>, and <span style=\"color: #33d079;\">tip</span>.\n\n Remember that all these faces (and any user or package-defined ones) can\n arbitrarily nest and overlap, <span style=\"color: #33d079;background-color: #3a3a3a;\">like <span style=\"font-weight: 700;font-style: italic;\">so</span></span>.</pre>","category":"page"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"\\begingroup\n\\ttfamily\n\\setlength{\\parindent}{0pt}\n\\setlength{\\parskip}{\\baselineskip}\n\nThe basic font-style attributes are {\\fontseries{b}\\selectfont bold}, {\\fontseries{l}\\selectfont light}, {\\fontshape{it}\\selectfont italic},\\\\\n\\underline{underline}, and {strikethrough}.\n\nIn terms of color, we have named faces for the 16 standard terminal colors:\\\\\n{\\color[HTML]{1c1a23}\\(\\blacksquare\\)} {\\color[HTML]{a51c2c}\\(\\blacksquare\\)} {\\color[HTML]{25a268}\\(\\blacksquare\\)}\n{\\color[HTML]{e5a509}\\(\\blacksquare\\)} {\\color[HTML]{195eb3}\\(\\blacksquare\\)} {\\color[HTML]{803d9b}\\(\\blacksquare\\)}\n{\\color[HTML]{0097a7}\\(\\blacksquare\\)} {\\color[HTML]{dddcd9}\\(\\blacksquare\\)} \\\\\n{\\color[HTML]{76757a}\\(\\blacksquare\\)} {\\color[HTML]{ed333b}\\(\\blacksquare\\)} {\\color[HTML]{33d079}\\(\\blacksquare\\)} {\\color[HTML]{f6d22c}\\(\\blacksquare\\)} {\\color[HTML]{3583e4}\\(\\blacksquare\\)} {\\color[HTML]{bf60ca}\\(\\blacksquare\\)} {\\color[HTML]{26c6da}\\(\\blacksquare\\)} {\\color[HTML]{f6f5f4}\\(\\blacksquare\\)}\n\nSince {\\color[HTML]{0097a7}bright\\_black} is effectively grey, we define two aliases for it:\\\\\n{\\color[HTML]{0097a7}grey} and {\\color[HTML]{0097a7}gray} to allow for regional spelling differences.\n\nTo flip the foreground and background colors of some text, you can use the\\\\\n{\\color[HTML]{0097a7}inverse} face, for example: {\\color[HTML]{803d9b}some \\colorbox[HTML]{803d9b}{\\color[HTML]{000000}inverse} text}.\n\nThe intent-based basic faces are {\\color[HTML]{76757a}shadow} (for dim but visible text),\\\\\n\\colorbox[HTML]{3a3a3a}{region} for selections, {\\color[HTML]{195eb3}emphasis}, and \\colorbox[HTML]{195eb3}{highlight}.\\\\\nAs above, {\\color[HTML]{0097a7}code} is used for code-like text.\n\nLastly, we have the 'message severity' faces: {\\color[HTML]{ed333b}error}, {\\color[HTML]{e5a509}warning},\\\\\n{\\color[HTML]{25a268}success}, {\\color[HTML]{26c6da}info}, {\\color[HTML]{76757a}note}, and {\\color[HTML]{33d079}tip}.\n\nRemember that all these faces (and any user or package-defined ones) can\\\\\narbitrarily nest and overlap, \\colorbox[HTML]{3a3a3a}{\\color[HTML]{33d079}like\n  {\\fontseries{b}\\fontshape{it}\\selectfont so}}.\n\\endgroup","category":"page"},{"location":"#stdlib-styledstrings-api","page":"StyledStrings","title":"API reference","text":"","category":"section"},{"location":"","page":"StyledStrings","title":"StyledStrings","text":"StyledStrings.@styled_str\nStyledStrings.styled\nStyledStrings.Face\nStyledStrings.addface!\nStyledStrings.withfaces\nStyledStrings.SimpleColor\nBase.parse(::Type{StyledStrings.SimpleColor}, ::String)\nBase.tryparse(::Type{StyledStrings.SimpleColor}, ::String)\nBase.merge(::StyledStrings.Face, ::StyledStrings.Face)","category":"page"},{"location":"#StyledStrings.StyledMarkup.@styled_str","page":"StyledStrings","title":"StyledStrings.StyledMarkup.@styled_str","text":"@styled_str -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures apply the formatting to <content>, according to the list of comma-separated specifications <specs>. Each spec can either take the form of a face name, an inline face specification, or a key=value pair. The value must be wrapped by {...} should it contain any of the characters ,=:{}.\n\nString interpolation with $ functions in the same way as regular strings, except quotes need to be escaped. Faces, keys, and values can also be interpolated with $.\n\nExample\n\nstyled\"The {bold:{italic:quick} {(foreground=#cd853f):brown} fox} jumped over the {link={https://en.wikipedia.org/wiki/Laziness}:lazy} dog\"\n\nExtended help\n\nThis macro can be described by the following EBNF grammar:\n\nstyledstring = { styled | interpolated | escaped | plain } ;\n\nspecialchar = '{' | '}' | '$' | '\\\"' ;\nanychar = [\\u0-\\u1fffff] ;\nplain = { anychar - specialchar } ;\nescaped = '\\\\', specialchar ;\n\ninterpolated = '$', ? expr ? | '$(', ? expr ?, ')' ;\n\nstyled = '{', ws, annotations, ':', content, '}' ;\ncontent = { interpolated | plain | escaped | styled } ;\nannotations = annotation | annotations, ws, ',', ws, annotation ;\nannotation = face | inlineface | keyvalue ;\nws = { ' ' | '\\t' | '\\n' } ; (* whitespace *)\n\nface = facename | interpolated ;\nfacename = [A-Za-z0-9_]+ ;\n\ninlineface = '(', ws, [ faceprop ], { ws, ',', faceprop }, ws, ')' ;\nfaceprop = [a-z]+, ws, '=', ws, ( [^,)]+ | interpolated) ;\n\nkeyvalue = key, ws, '=', ws, value ;\nkey = ( [^\\0${}=,:], [^\\0=,:]* ) | interpolated ;\nvalue = simplevalue | curlybraced | interpolated ;\ncurlybraced = '{' { escaped | plain } '}' ;\nsimplevalue = [^${},:], [^,:]* ;\n\nAn extra stipulation not encoded in the above grammar is that plain should be a valid input to unescape_string, with specialchar kept.\n\nThe above grammar for inlineface is simplified, as the actual implementation is a bit more sophisticated. The full behaviour is given below.\n\nfaceprop = ( 'face', ws, '=', ws, ( ? string ? | interpolated ) ) |\n           ( 'height', ws, '=', ws, ( ? number ? | interpolated ) ) |\n           ( 'weight', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( 'slant', ws, '=', ws, ( symbol | interpolated ) ) |\n           ( ( 'foreground' | 'fg' | 'background' | 'bg' ),\n               ws, '=', ws, ( simplecolor | interpolated ) ) |\n           ( 'underline', ws, '=', ws, ( underline | interpolated ) ) |\n           ( 'strikethrough', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inverse', ws, '=', ws, ( bool | interpolated ) ) |\n           ( 'inherit', ws, '=', ws, ( inherit | interpolated ) ) ;\n\nnothing = 'nothing' ;\nbool = 'true' | 'false' ;\nsymbol = [^ ,)]+ ;\nhexcolor = ('#' | '0x'), [0-9a-f]{6} ;\nsimplecolor = hexcolor | symbol | nothing ;\n\nunderline = nothing | bool | simplecolor | underlinestyled;\nunderlinestyled = '(', ws, ('' | nothing | simplecolor | interpolated), ws,\n                  ',', ws, ( symbol | interpolated ), ws ')' ;\n\ninherit = ( '[', inheritval, { ',', inheritval }, ']' ) | inheritval;\ninheritval = ws, ':'?, symbol ;\n\n\n\n\n\n","category":"macro"},{"location":"#StyledStrings.StyledMarkup.styled","page":"StyledStrings","title":"StyledStrings.StyledMarkup.styled","text":"styled(content::AbstractString) -> AnnotatedString\n\nConstruct a styled string. Within the string, {<specs>:<content>} structures apply the formatting to <content>, according to the list of comma-separated specifications <specs>. Each spec can either take the form of a face name, an inline face specification, or a key=value pair. The value must be wrapped by {...} should it contain any of the characters ,=:{}.\n\nThis is a functional equivalent of the @styled_str macro, just without interpolation capabilities.\n\n\n\n\n\n","category":"function"},{"location":"#StyledStrings.Face","page":"StyledStrings","title":"StyledStrings.Face","text":"A Face is a collection of graphical attributes for displaying text. Faces control how text is displayed in the terminal, and possibly other places too.\n\nMost of the time, a Face will be stored in the global faces dicts as a unique association with a face name Symbol, and will be most often referred to by this name instead of the Face object itself.\n\nAttributes\n\nAll attributes can be set via the keyword constructor, and default to nothing.\n\nheight (an Int or Float64): The height in either deci-pt (when an Int), or as a factor of the base size (when a Float64).\nweight (a Symbol): One of the symbols (from faintest to densest) :thin, :extralight, :light, :semilight, :normal, :medium, :semibold, :bold, :extrabold, or :black. In terminals any weight greater than :normal is displayed as bold, and in terminals that support variable-brightness text, any weight less than :normal is displayed as faint.\nslant (a Symbol): One of the symbols :italic, :oblique, or :normal.\nforeground (a SimpleColor): The text foreground color.\nbackground (a SimpleColor): The text background color.\nunderline, the text underline, which takes one of the following forms:\na Bool: Whether the text should be underlined or not.\n\na SimpleColor: The text should be underlined with this color.\n\na Tuple{Nothing, Symbol}: The text should be underlined using the style set by the Symbol, one of :straight, :double, :curly, :dotted, or :dashed.\n\na Tuple{SimpleColor, Symbol}: The text should be underlined in the specified SimpleColor, and using the style specified by the Symbol, as before.\nstrikethrough (a Bool): Whether the text should be struck through.\ninverse (a Bool): Whether the foreground and background colors should be inverted.\ninherit (a Vector{Symbol}): Names of faces to inherit from, with earlier faces taking priority. All faces inherit from the :default face.\n\n\n\n\n\n","category":"type"},{"location":"#StyledStrings.addface!","page":"StyledStrings","title":"StyledStrings.addface!","text":"addface!(name::Symbol => default::Face)\n\nCreate a new face by the name name. So long as no face already exists by this name, default is added to both FACES.default and (a copy of) to FACES.current, with the current value returned.\n\nShould the face name already exist, nothing is returned.\n\nExamples\n\njulia> addface!(:mypkg_myface => Face(slant=:italic, underline=true))\nFace (sample)\n         slant: italic\n     underline: true\n\n\n\n\n\n","category":"function"},{"location":"#StyledStrings.withfaces","page":"StyledStrings","title":"StyledStrings.withfaces","text":"withfaces(f, kv::Pair...)\nwithfaces(f, kvpair_itr)\n\nExecute f with FACES.current temporarily modified by zero or more :name => val arguments kv, or kvpair_itr which produces kv-form values.\n\nwithfaces is generally used via the withfaces(kv...) do ... end syntax. A value of nothing can be used to temporarily unset a face (if it has been set). When withfaces returns, the original FACES.current has been restored.\n\nExamples\n\njulia> withfaces(:yellow => Face(foreground=:red), :green => :blue) do\n           println(styled\"{yellow:red} and {green:blue} mixed make {magenta:purple}\")\n       end\nred and blue mixed make purple\n\n\n\n\n\n","category":"function"},{"location":"#StyledStrings.SimpleColor","page":"StyledStrings","title":"StyledStrings.SimpleColor","text":"struct SimpleColor\n\nA basic representation of a color, intended for string styling purposes. It can either contain a named color (like :red), or an RGBTuple which is a NamedTuple specifying an r, g, b color with a bit-depth of 8.\n\nConstructors\n\nSimpleColor(name::Symbol)  # e.g. :red\nSimpleColor(rgb::RGBTuple) # e.g. (r=1, b=2, g=3)\nSimpleColor(r::Integer, b::Integer, b::Integer)\nSimpleColor(rgb::UInt32)   # e.g. 0x123456\n\nAlso see tryparse(SimpleColor, rgb::String).\n\n\n\n\n\n","category":"type"},{"location":"#Base.parse-Tuple{Type{StyledStrings.SimpleColor}, String}","page":"StyledStrings","title":"Base.parse","text":"parse(::Type{SimpleColor}, rgb::String)\n\nAn analogue of tryparse(SimpleColor, rgb::String) (which see), that raises an error instead of returning nothing.\n\n\n\n\n\n","category":"method"},{"location":"#Base.tryparse-Tuple{Type{StyledStrings.SimpleColor}, String}","page":"StyledStrings","title":"Base.tryparse","text":"tryparse(::Type{SimpleColor}, rgb::String)\n\nAttempt to parse rgb as a SimpleColor. If rgb starts with # and has a length of 7, it is converted into a RGBTuple-backed SimpleColor. If rgb starts with a-z, rgb is interpreted as a color name and converted to a Symbol-backed SimpleColor.\n\nOtherwise, nothing is returned.\n\nExamples\n\njulia> tryparse(SimpleColor, \"blue\")\nSimpleColor(blue)\n\njulia> tryparse(SimpleColor, \"#9558b2\")\nSimpleColor(#9558b2)\n\njulia> tryparse(SimpleColor, \"#nocolor\")\n\n\n\n\n\n","category":"method"},{"location":"#Base.merge-Tuple{StyledStrings.Face, StyledStrings.Face}","page":"StyledStrings","title":"Base.merge","text":"merge(initial::Face, others::Face...)\n\nMerge the properties of the initial face and others, with later faces taking priority.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Everything documented in this page is internal and subject to breaking changes, even in minor version updates of Julia or StyledStrings.jl. If you are curious about the internals, read on, but if you want to depend on them, please consider opening a pull request or issue to discuss making them part of the public API.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"StyledStrings.ANSI_4BIT_COLORS\nStyledStrings.FACES\nStyledStrings.HTML_BASIC_COLORS\nStyledStrings.Legacy.ANSI_256_COLORS\nStyledStrings.Legacy.NAMED_COLORS\nStyledStrings.Legacy.RENAMED_COLORS\nStyledStrings.Legacy.legacy_color\nStyledStrings.Legacy.load_env_colors!\nStyledStrings.ansi_4bit_color_code\nStyledStrings.eachregion\nStyledStrings.annotation_events\nStyledStrings.face!\nStyledStrings.getface\nStyledStrings.loadface!\nStyledStrings.loaduserfaces!\nStyledStrings.resetfaces!\nStyledStrings.termcolor\nStyledStrings.termcolor24bit\nStyledStrings.termcolor8bit","category":"page"},{"location":"internals/#StyledStrings.ANSI_4BIT_COLORS","page":"Internals","title":"StyledStrings.ANSI_4BIT_COLORS","text":"A mapping between ANSI named colours and indices in the standard 256-color table. The standard colors are 0-7, and high intensity colors 8-15.\n\nThe high intensity colors are prefixed by \"bright\". The \"brightblack\" color is given two aliases: \"grey\" and \"gray\".\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.FACES","page":"Internals","title":"StyledStrings.FACES","text":"Globally named Faces.\n\ndefault gives the initial values of the faces, and current holds the active (potentially modified) set of faces. This two-set system allows for any modifications to the active faces to be undone.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.HTML_BASIC_COLORS","page":"Internals","title":"StyledStrings.HTML_BASIC_COLORS","text":"A mapping between ANSI named colors and 8-bit colors for use in HTML representations.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.ANSI_256_COLORS","page":"Internals","title":"StyledStrings.Legacy.ANSI_256_COLORS","text":"A mapping from 256-color codes indicies to 8-bit colours.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.NAMED_COLORS","page":"Internals","title":"StyledStrings.Legacy.NAMED_COLORS","text":"A list of all named colors recognised, including both the old light_* and new bright_* named colors.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.RENAMED_COLORS","page":"Internals","title":"StyledStrings.Legacy.RENAMED_COLORS","text":"A mapping from old named colours to the new names, specifically from light_* to bright_*.\n\n\n\n\n\n","category":"constant"},{"location":"internals/#StyledStrings.Legacy.legacy_color","page":"Internals","title":"StyledStrings.Legacy.legacy_color","text":"legacy_color(color::Union{String, Symbol, Int})\n\nAttempt to obtain a SimpleColor for a \"legacy\" color value color.\n\nWhen this is not possible, nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.Legacy.load_env_colors!","page":"Internals","title":"StyledStrings.Legacy.load_env_colors!","text":"load_env_colors!()\n\nTry to emulate the effect of the various *_color() functions of Base, by loading any specified colours as foregrounds of the relevant faces.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.ansi_4bit_color_code","page":"Internals","title":"StyledStrings.ansi_4bit_color_code","text":"ansi_4bit_color_code(color::Symbol, background::Bool=false)\n\nProvide the color code (30-37, 40-47, 90-97, 100-107) for color, as an integer. When background is set the background variant will be provided, otherwise the provided code is for setting the foreground color.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.eachregion","page":"Internals","title":"StyledStrings.eachregion","text":"eachregion(s::AnnotatedString{S})\neachregion(s::SubString{AnnotatedString{S}})\n\nIdentify the contiguous substrings of s with a constant annotations, and return an iterator which provides each substring and the applicable annotations as a Tuple{SubString{S}, Vector{Pair{Symbol, Any}}}.\n\nExamples\n\njulia> collect(StyledStrings.eachregion(Base.AnnotatedString(\n           \"hey there\", [(1:3, :face => :bold), (5:9, :face => :italic)])))\n3-element Vector{Tuple{SubString{String}, Vector{Pair{Symbol, Any}}}}:\n (\"hey\", [:face => :bold])\n (\" \", [])\n (\"there\", [:face => :italic])\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.annotation_events","page":"Internals","title":"StyledStrings.annotation_events","text":"annotation_events(string::AbstractString, annots::Vector{Tuple{UnitRange{Int64}, Pair{Symbol, Any}}}, subregion::UnitRange{Int})\nannotation_events(string::AnnotatedString, subregion::UnitRange{Int})\n\nFind all annotation \"change events\" that occur within a subregion of annots, with respect to string. When string is styled, annots is inferred.\n\nEach change event is given in the form of a @NamedTuple{pos::Int, active::Bool, index::Int} where pos is the position of the event, active is a boolean indicating whether the annotation is being activated or deactivated, and index is the index of the annotation in question.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.face!","page":"Internals","title":"StyledStrings.face!","text":"face!(str::Union{<:AnnotatedString, <:SubString{<:AnnotatedString}},\n      [range::UnitRange{Int},] face::Union{Symbol, Face})\n\nApply face to str, along range if specified or the whole of str.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.getface","page":"Internals","title":"StyledStrings.getface","text":"getface(faces)\n\nObtain the final merged face from faces, an iterator of Faces, face name Symbols, and lists thereof.\n\n\n\n\n\ngetface(annotations::Vector{Pair{Symbol, Any}})\n\nCombine all of the :face annotations with getfaces.\n\n\n\n\n\ngetface()\n\nObtain the default face.\n\n\n\n\n\ngetface(s::AnnotatedString, i::Integer)\n\nGet the merged Face that applies to s at index i.\n\n\n\n\n\ngetface(c::AnnotatedChar)\n\nGet the merged Face that applies to c.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.loadface!","page":"Internals","title":"StyledStrings.loadface!","text":"loadface!(name::Symbol => update::Face)\n\nMerge the face name in FACES.current with update. If the face name does not already exist in FACES.current, then it is set to update. To reset a face, update can be set to nothing.\n\nExamples\n\njulia> loadface!(:red => Face(foreground=0xff0000))\nFace (sample)\n    foreground: #ff0000\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.loaduserfaces!","page":"Internals","title":"StyledStrings.loaduserfaces!","text":"loaduserfaces!(faces::Dict{String, Any})\n\nFor each face specified in Dict, load it to FACES.current.\n\n\n\n\n\nloaduserfaces!(tomlfile::String)\n\nLoad all faces declared in the Faces.toml file tomlfile.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.resetfaces!","page":"Internals","title":"StyledStrings.resetfaces!","text":"resetfaces!()\n\nReset the current global face dictionary to the default value.\n\n\n\n\n\nresetfaces!(name::Symbol)\n\nReset the face name to its default value, which is returned.\n\nIf the face name does not exist, nothing is done and nothing returned. In the unlikely event that the face name does not have a default value, it is deleted, a warning message is printed, and nothing returned.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.termcolor","page":"Internals","title":"StyledStrings.termcolor","text":"termcolor(io::IO, color::SimpleColor, category::Char)\n\nPrint to io the SGR code to set the category's slot to color, where category is set as follows:\n\n'3' sets the foreground color\n'4' sets the background color\n'5' sets the underline color\n\nIf color is a SimpleColor{Symbol}, the value should be a a member of ANSI_4BIT_COLORS. Any other value will cause the color to be reset.\n\nIf color is a SimpleColor{RGBTuple} and get_have_truecolor() returns true, 24-bit color is used. Otherwise, an 8-bit approximation of color is used.\n\n\n\n\n\ntermcolor(io::IO, ::Nothing, category::Char)\n\nPrint to io the SGR code to reset the color for category.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.termcolor24bit","page":"Internals","title":"StyledStrings.termcolor24bit","text":"termcolor24bit(io::IO, color::RGBTuple, category::Char)\n\nPrint to io the 24-bit SGR color code to set the category8 slot to color.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.termcolor8bit","page":"Internals","title":"StyledStrings.termcolor8bit","text":"termcolor8bit(io::IO, color::RGBTuple, category::Char)\n\nPrint to io the best 8-bit SGR color code that sets the category color to be close to color.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Styled-Markup-parsing","page":"Internals","title":"Styled Markup parsing","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"While some of the internals above are useful outside StyledStrings, and unlikely to be broken (but with no guarantees!), apart from the exported string macro and styled function, the details of StyledMarkup documented below consists entirely of implementation details that should under no circumstances be referenced outside of StyledStrings .","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"If you're curious about how exactly styled markup strings are parsed, they should provide some insight though.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"StyledStrings.StyledMarkup\nStyledStrings.StyledMarkup.State\nStyledStrings.StyledMarkup.isnextchar\nStyledStrings.StyledMarkup.ismacro\nStyledStrings.StyledMarkup.styerr!\nStyledStrings.StyledMarkup.hygienic_eval\nStyledStrings.StyledMarkup.addpart!\nStyledStrings.StyledMarkup.escaped!\nStyledStrings.StyledMarkup.interpolated!\nStyledStrings.StyledMarkup.readexpr!\nStyledStrings.StyledMarkup.skipwhitespace!\nStyledStrings.StyledMarkup.read_while!\nStyledStrings.StyledMarkup.begin_style!\nStyledStrings.StyledMarkup.end_style!\nStyledStrings.StyledMarkup.read_annotation!\nStyledStrings.StyledMarkup.read_inlineface!\nStyledStrings.StyledMarkup.read_face_or_keyval!\nStyledStrings.StyledMarkup.run_state_machine!\nStyledStrings.StyledMarkup.annotatedstring_optimize!","category":"page"},{"location":"internals/#StyledStrings.StyledMarkup","page":"Internals","title":"StyledStrings.StyledMarkup","text":"StyledMarkup\n\nA sub-module of StyledStrings that specifically deals with parsing styled markup strings. To this end, two entrypoints are provided:\n\nThe styled\"\" string macro, which is generally preferred.\nThey styled function, which allows for use with runtime-provided strings, when needed.\n\nOverall, this module essentially functions as a state machine with a few extra niceties (like detailed error reporting) sprinkled on top. The overall design can be largely summed up with the following diagram:\n\n╭String─────────╮\n│ Styled markup │\n╰──────┬────────╯\n       │╭╴[module]\n       ││\n      ╭┴┴State─╮\n      ╰┬───────╯\n       │\n ╭╴run_state_machine!╶╮\n │              ╭─────┼─╼ escaped!\n │ Apply rules: │     │\n │  \"\\\\\" ▶──────╯ ╭───┼─╼[interpolated!] ──▶ readexpr!, addpart!\n │  \"$\" ▶────────╯   │\n │  \"{\"  ▶────────────┼─╼ begin_style! ──▶ read_annotation!\n │  \"}\"  ▶─────╮      │                     ├─╼ read_inlineface! [readexpr!]\n │             ╰──────┼─╼ end_style!        ╰─╼ read_face_or_keyval!\n │ addpart!(...)      │\n ╰╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╯\n       │\n       ▼\n     Result\n\nOf course, as usual, the devil is in the details.\n\n\n\n\n\n","category":"module"},{"location":"internals/#StyledStrings.StyledMarkup.State","page":"Internals","title":"StyledStrings.StyledMarkup.State","text":"State\n\nA struct representing of the parser state (if you squint, a state monad even).\n\nTo create the initial state, use the constructor:     State(content::AbstractString, mod::Union{Module, Nothing}=nothing) -> State\n\nIts fields are as follows:\n\ncontent::String, the (unescaped) input string\nbytes::Vector{UInt8}, the codeunits of content. This is a Vector{UInt8} instead of a CodeUnits{UInt8} because we need to be able to modify the array, for instance when erasing escape characters.\ns::Iterators.Stateful, an (index, char) iterator of content\nmod::Union{Module, Nothing}, the (optional) context with which to evaluate inline expressions in. This should be provided iff the styled markup comes from a macro invocation.\nparts::Vector{Any}, the result of the parsing, a list of elements that when passed to annotatedstring produce the styled markup string. The types of its values are highly diverse, hence the Any element type.\nactive_styles::Vector{Vector{Tuple{Int, Int, Union{Symbol, Expr, Pair{Symbol, Any}}}}}}, A list of batches of styles that have yet to be applied to any content. Entries of a batch consist of (source_position, start_position, style) tuples, where style may be just a symbol (referring to a face), a Pair{Symbol, Any} annotation, or an Expr that evaluates to a valid annotation (when mod is set).\npending_styles::Vector{Tuple{UnitRange{Int}, Union{Symbol, Expr, Pair{Symbol, Any}}}}, A list of styles that have been terminated, and so are known to occur over a certain range, but have yet to be applied.\noffset::RefValue{Int}, a record of the between the content index and the index in the resulting styled string, as markup structures are absorbed.\npoint::RefValue{Int}, the current index in content.\nescape::RefValue{Bool}, whether the last character seen was an escape character.\ninterpolated::RefValue{Bool}, whether any interpolated values have been seen. Knowing whether or not anything needs to be evaluated allows the resulting string to be computed at macroexpansion time, when possible.\nerrors::Vector, any errors raised during parsing. We collect them instead of immediately throwing so that we can list as many issues as possible at once, instead of forcing the author of the invalid styled markup to resolve each issue one at a time. This is expected to be populated by invocations of styerr!.\n\n\n\n\n\n","category":"type"},{"location":"internals/#StyledStrings.StyledMarkup.isnextchar","page":"Internals","title":"StyledStrings.StyledMarkup.isnextchar","text":"isnextchar(state::State, char::Char) -> Bool\nisnextchar(state::State, chars::NTuple{N, Char}) -> Bool\n\nCheck if state has a next character, and if so whether it is char or one of chars.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.ismacro","page":"Internals","title":"StyledStrings.StyledMarkup.ismacro","text":"ismacro(state::State) -> Bool\n\nCheck whether state is indicated to come from a macro invocation, according to whether state.mod is set or not.\n\nWhile this function is rather trivial, it clarifies the intent when used instead of just checking state.mod.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.styerr!","page":"Internals","title":"StyledStrings.StyledMarkup.styerr!","text":"styerr!(state::State, message::AbstractString, position::Union{Nothing, Int}=nothing, hint::String=\"around here\")\n\nRegister an error in state based on erroneous content at or around position (if known, and with a certain hint as to the location), with the nature of the error given by message.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.hygienic_eval","page":"Internals","title":"StyledStrings.StyledMarkup.hygienic_eval","text":"hygienic_eval(state::State, expr)\n\nEvaluate expr within the scope of state's module. This replicates part of the behind-the-scenes behaviour of macro expansion, we just need to manually invoke it due to the particularities around dealing with code from a foreign module that we parse ourselves.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.addpart!","page":"Internals","title":"StyledStrings.StyledMarkup.addpart!","text":"addpart!(state::State, stop::Int)\n\nCreate a new part from state.point to stop, applying all pending styles.\n\nThis consumes all the content between state.point and  stop, and shifts state.point to be the index after stop.\n\n\n\n\n\naddpart!(state::State, start::Int, expr, stop::Int)\n\nCreate a new part based on (the eventual evaluation of) expr, running from start to stop, taking the currently active styles into account.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.escaped!","page":"Internals","title":"StyledStrings.StyledMarkup.escaped!","text":"escaped!(state::State, i::Int, char::Char)\n\nParse the escaped character char, at index i, into state\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.interpolated!","page":"Internals","title":"StyledStrings.StyledMarkup.interpolated!","text":"interpolated!(state::State, i::Int, _)\n\nInterpolate the expression starting at i, and add it as a part to state.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.readexpr!","page":"Internals","title":"StyledStrings.StyledMarkup.readexpr!","text":"readexpr!(state::State, pos::Int = first(popfirst!(state.s)) + 1)\n\nRead the expression starting at pos in state.content, and consume state.s as appropriate to align the iterator to the end of the expression.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.skipwhitespace!","page":"Internals","title":"StyledStrings.StyledMarkup.skipwhitespace!","text":"skipwhitespace!(state::State)\n\nSkip forwards all space, tab, and newline characters in state.s\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.read_while!","page":"Internals","title":"StyledStrings.StyledMarkup.read_while!","text":"read_while!(f::Function, state::Base.Stateful, lastchar::Char)\n\nRead state until f(::Char) is false.\n\nGiven a Stateful that iterates (_, char::Char) pairs, and a predicate f(::Char)::Bool, return (str, lastchar), where str::String contains all the char for which f(char) == true, and lastchar the last char element seen, or the input lastchar there are no elements of state.\n\nExamples\n\njulia> s = Base.Stateful(pairs(\"abc\"));\n\njulia> read_while!(isnumeric, s, 'w')\n(\"\", 'a')\n\njulia> first(s) # s is mutated\n2 => 'b'\n\njulia> read_while!(isascii, Base.Stateful(pairs(\"123Σω\")), 'k')\n(\"123\", 'Σ')\n\njulia> read_while!(isascii, Base.Stateful(pairs(\"abcde\")), 'α')\n(\"abcde\", 'e')\n\njulia> read_while!(isascii , Base.Stateful(pairs(\"\")), 'k')\n(\"\", 'k')\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.begin_style!","page":"Internals","title":"StyledStrings.StyledMarkup.begin_style!","text":"begin_style!(state::State, i::Int, char::Char)\n\nParse the style declaration beginning at i (char) with read_annotation!, and register it in the active styles list.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.end_style!","page":"Internals","title":"StyledStrings.StyledMarkup.end_style!","text":"end_style!(state::State, i::Int, char::Char)\n\nClose of the most recent active style in state, making it a pending style.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.read_annotation!","page":"Internals","title":"StyledStrings.StyledMarkup.read_annotation!","text":"read_annotation!(state::State, i::Int, char::Char, newstyles::Vector) -> Bool\n\nRead the annotations at i (char), and push the style read to newstyles.\n\nThis skips whitespace and checks what the next character in state.s is, detects the form of the annotation, and parses it using the appropriate specialised function like so:\n\n:, end of annotation, do nothing\n(, inline face declaration, use read_inlineface!\notherwise, use read_face_or_keyval!\n\nAfter parsing the annotation, returns a boolean value signifying whether there is an immediately subsequent annotation to be read.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.read_inlineface!","page":"Internals","title":"StyledStrings.StyledMarkup.read_inlineface!","text":"read_inlineface!(state::State, i::Int, char::Char, newstyles)\n\nRead an inline face declaration from state, at position i (char), and add it to newstyles.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.read_face_or_keyval!","page":"Internals","title":"StyledStrings.StyledMarkup.read_face_or_keyval!","text":"read_face_or_keyval!(state::State, i::Int, char::Char, newstyles)\n\nRead an inline face or key-value pair from state at position i (char), and add it to newstyles.\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.run_state_machine!","page":"Internals","title":"StyledStrings.StyledMarkup.run_state_machine!","text":"run_state_machine!(state::State)\n\nIterate through state.s, applying the parsing rules for the top-level of syntax and calling the relevant specialised functions.\n\nUpon completion, state.s should be fully consumed and state.parts fully populated (along with state.errors).\n\n\n\n\n\n","category":"function"},{"location":"internals/#StyledStrings.StyledMarkup.annotatedstring_optimize!","page":"Internals","title":"StyledStrings.StyledMarkup.annotatedstring_optimize!","text":"annotatedstring_optimize!(str::AnnotatedString)\n\nMerge contiguous identical annotations in str.\n\n\n\n\n\n","category":"function"}]
}
